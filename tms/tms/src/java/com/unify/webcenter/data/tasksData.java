//   Generated by FlechaRoja Tech Tools (2003) 
package com.unify.webcenter.data;

import java.math.BigDecimal;
import java.text.*;
import java.util.Calendar;
import java.util.Locale;
import java.util.TimeZone;

/**  
 * Class that represent the table tasks
 * @author Administrator
 */
public class tasksData extends mainData {

    protected int owner;
    protected int project;
    protected java.sql.Timestamp start_date;
    protected java.sql.Timestamp reply_quotation_date;
    protected int assigned_to;
    protected java.sql.Timestamp created;
    protected java.sql.Timestamp modified;
    // protected char[] comments;
    protected String comments;
    protected java.math.BigDecimal estimated_time;
    protected int completion;
    protected int tolerance;
    protected String collect;
    protected int id;
    protected int topic;
    protected int status;
    protected int message;
    protected java.math.BigDecimal fare;
    //protected char[] description;
    protected String description;
    protected java.sql.Timestamp due_date;
    protected java.sql.Timestamp real_due_date;
    protected int reply_quotation_member;
    protected java.math.BigDecimal actual_time;
    protected int priority;
    protected String severity;
    protected int type_task;
    protected java.sql.Timestamp assigned;
    protected String published;
    protected java.sql.Timestamp send_quotation_date;
    protected String name;
    protected int predecessor;
    protected String predecessor_required;
    protected boolean isLate;
    protected int totalCalendarTime;
    protected String spread_fix;
    protected java.math.BigDecimal totalScheduledHours; // Cantidad de horas que en horarios/calendarios 
    protected java.math.BigDecimal totalCalendarHours;  // estan definidas y es cargado al ejecutar el reporte
    // de rendimientos.
    protected membersData parentAssigned;
    protected projectsData parentProject;
    protected type_tasksData parentTypeTask;
    protected java.util.Vector assignmentsList;
    protected java.util.Vector filesList;
    private int id_account;
    private java.sql.Timestamp start_status_date;
    private java.sql.Timestamp end_status_date;
    private java.sql.Timestamp end_client_status_date;
    private boolean hasErrors;
    private int emailNotifyTQA;
    private int emailNotifyFQA;
    
    private int version_control;
    private int operation_number;
    
    public tasksData() {
        hasErrors=false;
    }

    public tasksData(tasksData val) {
        this.owner = val.getowner();
        this.project = val.getproject();
        this.start_date = val.getstart_date();
        this.reply_quotation_date = val.getreply_quotation_date();
        this.assigned_to = val.getassigned_to();
        this.created = val.getcreated();
        this.modified = val.getmodified();
        this.comments = val.getcomments();
        this.estimated_time = val.getestimated_time();
        this.completion = val.getcompletion();
        this.tolerance = val.gettolerance();
        this.collect = val.getcollect();
        this.id = val.getid();
        this.topic = val.gettopic();
        this.status = val.getstatus();
        this.message = val.getmessage();
        this.fare = val.getfare();
        this.description = val.getdescription();
        this.due_date = val.getdue_date();
        this.real_due_date = val.getreal_due_date();
        this.reply_quotation_member = val.getreply_quotation_member();
        this.actual_time = val.getactual_time();
        this.priority = val.getpriority();
        this.severity = val.getseverity();
        this.type_task = val.gettype_task();
        this.assigned = val.getassigned();
        this.published = val.getpublished();
        this.send_quotation_date = val.getsend_quotation_date();
        this.name = val.getname();
        this.predecessor = val.getpredecessor();
        this.predecessor_required = val.getpredecessor_required();
        this.spread_fix = val.getspread_fix();
        totalCalendarTime = 0;
    }

    public void setowner(int val) {
        owner = val;
    }

    public void setproject(int val) {
        project = val;
    }

    public void setstart_date(java.sql.Timestamp val) {
        start_date = val;
    }

    public void setreply_quotation_date(java.sql.Timestamp val) {
        reply_quotation_date = val;
    }

    public void setassigned_to(int val) {
        assigned_to = val;
    }

    public void setcreated(java.sql.Timestamp val) {
        created = val;
    }

    public void setmodified(java.sql.Timestamp val) {
        modified = val;
    }

    /*public void setcomments(char[] val) {
    comments = val;
    }
    public void setcomments(String val) {
    if (comments != null) {
    comments = val.toCharArray();
    }
    }*/
    public void setcomments(String val) {
        comments = val;
    }

    public void setestimated_time(java.math.BigDecimal val) {
        estimated_time = val;
    }

    public void setcompletion(int val) {
        completion = val;
    }

    public void settolerance(int val) {
        tolerance = val;
    }

    public void setcollect(String val) {
        collect = val;
    }

    public void setid(int val) {
        id = val;
    }

    public void settopic(int val) {
        topic = val;
    }

    public void setstatus(int val) {
        status = val;
    }

    public void setfare(java.math.BigDecimal val) {
        fare = val;
    }

    /* public void setdescription(char[] val) {
    description = val;
    }*/
    public void setdescription(String val) {
        description = val;
    }

    public void setspread_fix(String val) {
        spread_fix = val;
    }

    /*   public void setdescription(String val) {
    if (description != null) {
    description = val.toCharArray();
    }
    }*/
    public void setdue_date(java.sql.Timestamp val) {
        due_date = val;
    }

    public void setreal_due_date(java.sql.Timestamp val) {
        real_due_date = val;
    }

    public void setreply_quotation_member(int val) {
        reply_quotation_member = val;
    }

    public void setactual_time(java.math.BigDecimal val) {
        actual_time = val;
    }

    public void setpriority(int val) {
        priority = val;
    }

    public void setseverity(String val) {
        severity = val;
    }

    public void settype_task(int val) {
        type_task = val;
    }

    public void setassigned(java.sql.Timestamp val) {
        assigned = val;
    }

    public void setpublished(String val) {
        published = val;
    }

    public void setsend_quotation_date(java.sql.Timestamp val) {
        send_quotation_date = val;
    }

    public void setname(String val) {
        name = this.cleanInvalidTags(val);
    }

    public void setmessage(int val) {
        message = val;
    }

    public void setparentAssigned(membersData val) {
        parentAssigned = val;
    }

    public void setassignmentsList(java.util.Vector val) {
        assignmentsList = val;
    }

    public void setparentTypeTask(type_tasksData val) {
        parentTypeTask = val;
    }

    public void setfilesList(java.util.Vector val) {
        filesList = val;
    }

    public void setparentProject(projectsData val) {
        parentProject = val;
    }

    public void setpredecessor(int val) {
        predecessor = val;
    }

    public void setpredecessor_required(String val) {
        predecessor_required = val;
    }

    public int getowner() {
        return owner;
    }

    public int getproject() {
        return project;
    }

    public java.sql.Timestamp getstart_date() {
        return start_date;
    }

    public java.sql.Timestamp getreply_quotation_date() {
        return reply_quotation_date;
    }

    public int getassigned_to() {
        return assigned_to;
    }

    public java.sql.Timestamp getcreated() {
        return created;
    }

    public java.sql.Timestamp getmodified() {
        return modified;
    }

    /*  public char[] getcomments() {
    return comments;
    }*/
    public String getcomments() {
        return comments;
    }

    public java.math.BigDecimal getestimated_time() {
        return estimated_time;
    }

    public int getcompletion() {
        return completion;
    }

    public int gettolerance() {
        return tolerance;
    }

    public String getcollect() {
        return collect;
    }

    public int getid() {
        return id;
    }

    public int gettopic() {
        return topic;
    }

    public int getstatus() {
        return status;
    }

    public java.math.BigDecimal getfare() {
        return fare;
    }

    /* public char[] getdescription() {
    return description;
    }*/
    public String getdescription() {
        return description;
    }

    public java.sql.Timestamp getdue_date() {
        return due_date;
    }

    public java.sql.Timestamp getreal_due_date() {
        return real_due_date;
    }

    public int getreply_quotation_member() {
        return reply_quotation_member;
    }

    public java.math.BigDecimal getactual_time() {
        return actual_time;
    }

    public int getpriority() {
        return priority;
    }

    public String getseverity() {
        return severity;
    }

    public int gettype_task() {
        return type_task;
    }

    public java.sql.Timestamp getassigned() {
        return assigned;
    }

    public String getpublished() {
        return published;
    }

    public java.sql.Timestamp getsend_quotation_date() {
        return send_quotation_date;
    }

    public String getname() {
        return cleanInvalidTags(name);
    }

    public int getmessage() {
        return message;
    }

    public membersData getparentAssigned() {
        return parentAssigned;
    }

    public projectsData getparentProject() {
        return parentProject;
    }

    public type_tasksData getparentTypeTask() {
        return parentTypeTask;
    }

    public java.util.Vector getassignmentsList() {
        return assignmentsList;
    }

    public java.util.Vector getfilesList() {
        return filesList;
    }

    public int getpredecessor() {
        return predecessor;
    }

    public String getpredecessor_required() {
        return predecessor_required;
    }

    public String getspread_fix() {
        return spread_fix;
    }

    // Regresa la descripcion en formato HTML
    public String getFormatedDescription() {
        if (description != null) {
            StringBuffer temp = new StringBuffer(new String(description));

            // Los cambios de linea
            int i = temp.indexOf("\\n");
            while (i > 0) {
                temp.replace(i, i + 2, "<br>");
                i = temp.indexOf("\\n");
            }

            // Los cambios de linea
            i = temp.indexOf("\n");
            while (i > 0) {
                temp.replace(i, i + 1, "<br>");
                i = temp.indexOf("\n");
            }


            // Los tabs tambien       
            i = temp.indexOf("\\t");
            while (i > 0) {
                temp.replace(i, i + 2, "   ");
                i = temp.indexOf("\\t");
            }

            // Los tabs tambien       
            i = temp.indexOf("\t");
            while (i > 0) {
                temp.replace(i, i + 1, "   ");
                i = temp.indexOf("\t");
            }

            return temp.toString();
        } else {
            return "";
        }
    }

    /*
     * Se obtiene el campo de comentarios formateado en lineas de 100
     * caracteres
     */
    public String getFormatedComments() {
        if (description != null) {
            StringBuffer temp = new StringBuffer(new String(comments));

            // Los cambios de linea
            int len = temp.length(), i = 100;
            while (i < len) {
                temp = temp.insert(i, "<br>");
                i += 100;
            }

            return temp.toString();
        } else {
            return "";
        }
    }

    // Setea la cantidad de horas de calendario
    public void setTotalScheduledHours(java.math.BigDecimal val) {
        totalScheduledHours = val;
    }

    // Setea la cantidad de horas de calendario
    public java.math.BigDecimal getTotalScheduledHours() {
        return totalScheduledHours;
    }


    // Setea la cantidad de horas de calendario
    public void setTotalCalendarHours(java.math.BigDecimal val) {
        totalCalendarHours = val;
    }

    // Setea la cantidad de horas de calendario
    public java.math.BigDecimal getTotalCalendarHours() {
        return totalCalendarHours;
    }

    // Metodo que determina si esta tarea tiene al menos un archivo publicado
    public boolean hasPublishedFiles() {
        boolean tiene = false;
        filesData data;
        for (int i = 0; i < filesList.size(); i++) {
            data = (filesData) filesList.get(i);
            if (data.getpublished().equals("1")) {
                tiene = true;
                i = filesList.size();
            }
        }

        return tiene;
    }

    // Retorna true si esta tarea ha expirado.
    public boolean expired() {
        // Los estatus del 2 al 6 son los unicos que deben ser considerados
        // para retraso, el resto NO.
        if ((status >= 2 && status <= 6) || (status == 12)) {
            if (due_date != null) {
                return due_date.before(new java.sql.Timestamp(
                        java.util.Calendar.getInstance().getTimeInMillis()));
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    public boolean isLate() {
        return isLate;
    }

    public void setLate(boolean val) {
        isLate = val;
    }

    // Regresa la fecha de entrega formateada de forma apropiada.
    public String getFormatedDueDate() {
        try {
            java.text.DateFormat df = java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM);
            return df.format(due_date);
        } catch (Exception e) {
            return "";
        }

    }

    // Regresa la fecha de entrega formateada de forma apropiada.
    public String getFormatedDueDateForPortal() {
        try {
            if (this.parentProject.getpublished_endtask().equalsIgnoreCase("1")) {
                java.text.DateFormat df = java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM);
                return df.format(due_date);
            } else {
                return "--";
            }
        } catch (Exception e) {
            return "";
        }

    }

    // Regresa la fecha de entrega formateada de forma apropiada.
    public String getFormatedStartDate() {
        try {
            java.text.DateFormat df = java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM);
            return df.format(start_date);
        } catch (Exception e) {
            return "";
        }
    }

    // Regresa la fecha de entrega formateada de forma apropiada.
    public String getFormatedRealDueDate() {
        java.text.DateFormat df = java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM);
        return df.format(real_due_date);
    }

    // Regresa la fecha de entrega formateada de forma apropiada.
    public String getFormatedDueDate_es() {
        try {
            java.text.DateFormat df = java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM, new Locale("es"));

            return df.format(due_date);
        } catch (Exception e) {
            return "";
        }
    }

    // Regresa la fecha de entrega formateada de forma apropiada.
    public String getFormatedStartDate_es() {
        try {
            java.text.DateFormat df = java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM, new Locale("es"));
            return df.format(start_date);
        } catch (Exception e) {
            return "";
        }
    }

    // Regresa la fecha de entrega formateada de forma apropiada.
    public String getFormatedRealDueDate_es() {
        try {
            java.text.DateFormat df = java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM, new Locale("es"));
            return df.format(real_due_date);
        } catch (Exception e) {
            return "";
        }
    }

    /* Se obtiene el rendimiento de esta tarea, el cual viene dado por la formula
     *   (Tiempo_Estimado/Tiempo_Actual) * 100.
     *   Si Tiempo_Actual = 0 implica que el rendimiento es 0
     */
    public java.math.BigDecimal getperformance() {
  /*      java.math.BigDecimal salida;
        // Para evitar una division por 0
        if (actual_time.longValue() == 0) {
            salida = new java.math.BigDecimal(0);
        } else {
            salida = new java.math.BigDecimal(
                    estimated_time.doubleValue() / actual_time.doubleValue());

//                salida = estimated_time.divide(actual_time,
//                     java.math.BigDecimal.ROUND_DOWN);             
            salida = salida.multiply(new java.math.BigDecimal(100));
            salida = salida.setScale(2, java.math.BigDecimal.ROUND_DOWN);
        }

        return salida;*/
        return getEfficiency();
    }

    public BigDecimal getEfficiency() {
        BigDecimal salida = new BigDecimal(0);
        // Para evitar una division por 0
        if (actual_time.compareTo(new BigDecimal(0.0)) == 0 || actual_time.compareTo(new BigDecimal(0)) == 0 || estimated_time.compareTo(new BigDecimal(0.0)) == 0 || estimated_time.compareTo(new BigDecimal(0)) == 0) {
            salida = new BigDecimal(0);
        } else {
            BigDecimal hour_actual = new BigDecimal(0);
            BigDecimal min_actual = new BigDecimal(0);
            if (actual_time.toString().replace('.', ',').split(",").length > 1) {
                String[] split_min = null;
                String replace_min = actual_time.toString().replace('.', ',');
                split_min = replace_min.split(",");
                hour_actual = new BigDecimal(split_min[0]).multiply(new BigDecimal(60));
                min_actual = new BigDecimal(split_min[1]);
                if (split_min[1].length() == 1) {
                    min_actual = min_actual.multiply(new BigDecimal(10));
                }
                min_actual = min_actual.add(hour_actual);
            } else {
                min_actual = actual_time.multiply(new BigDecimal(60));
            }
            BigDecimal hour_estimated = new BigDecimal(0);
            BigDecimal min_estimated = new BigDecimal(0);
            if (estimated_time.toString().replace('.', ',').split(",").length > 1) {
                String[] split_min_e = null;
                String replace_min_e = estimated_time.toString().replace('.', ',');
                split_min_e = replace_min_e.split(",");
                hour_estimated = new BigDecimal(split_min_e[0]).multiply(new BigDecimal(60));
                min_estimated = new BigDecimal(split_min_e[1]);
                if (split_min_e[1].length() == 1) {
                    min_estimated = min_estimated.multiply(new BigDecimal(10));
                }
                min_estimated = min_estimated.add(hour_estimated);
            } else {
                min_estimated = estimated_time.multiply(new BigDecimal(60));
            }
            salida = new BigDecimal(min_estimated.doubleValue() / min_actual.doubleValue());
            salida = salida.multiply(new BigDecimal(100));
            salida = salida.setScale(2, java.math.BigDecimal.ROUND_DOWN);
        }
        return salida;
    }

    /* Se obtiene el rendimiento de esta tarea, el cual viene dado por la formula
     *   (Tiempo_Estimado/Tiempo_Actual) * 100.
     *   Si Tiempo_Actual = 0 implica que el rendimiento es 0
     */
    public java.math.BigDecimal getPerformanceUsingSchedule() {
        BigDecimal salida = new BigDecimal(0);
        // Para evitar una division por 0
        if (totalScheduledHours.compareTo(new BigDecimal(0.0)) == 0 ||
                totalScheduledHours.compareTo(new BigDecimal(0)) == 0 ||
                estimated_time.compareTo(new BigDecimal(0.0)) == 0 ||
                estimated_time.compareTo(new BigDecimal(0)) == 0) {
            salida = new BigDecimal(0);
        } else {
            BigDecimal hour_total = new BigDecimal(0);
            BigDecimal min_total = new BigDecimal(0);
            if (totalScheduledHours.toString().replace('.', ',').split(",").length > 1) {
                String[] split_min = null;
                String replace_min = totalScheduledHours.toString().replace('.', ',');
                split_min = replace_min.split(",");
                hour_total = new BigDecimal(split_min[0]).multiply(new BigDecimal(60));
                min_total = new BigDecimal(split_min[1]);
                if (split_min[1].length() == 1) {
                    min_total = min_total.multiply(new BigDecimal(10));
                }
                min_total = min_total.add(hour_total);
            } else {
                min_total = totalScheduledHours.multiply(new BigDecimal(60));
            }
            BigDecimal hour_estimated = new BigDecimal(0);
            BigDecimal min_estimated = new BigDecimal(0);
            if (estimated_time.toString().replace('.', ',').split(",").length > 1) {
                String[] split_min_e = null;
                String replace_min_e = estimated_time.toString().replace('.', ',');
                split_min_e = replace_min_e.split(",");
                hour_estimated = new BigDecimal(split_min_e[0]).multiply(new BigDecimal(60));
                min_estimated = new BigDecimal(split_min_e[1]);
                if (split_min_e[1].length() == 1) {
                    min_estimated = min_estimated.multiply(new BigDecimal(10));
                }
                min_estimated = min_estimated.add(hour_estimated);
            } else {
                min_estimated = estimated_time.multiply(new BigDecimal(60));
            }
            salida = new BigDecimal(min_estimated.doubleValue() / min_total.doubleValue());
            salida = salida.multiply(new BigDecimal(100));
            salida = salida.setScale(2, java.math.BigDecimal.ROUND_DOWN);
        }
        /*      java.math.BigDecimal salida;
        // Para evitar una division por 0
        if (totalScheduledHours.longValue() == 0) {
        salida = new java.math.BigDecimal(0);
        } else {
        salida = new java.math.BigDecimal(
        estimated_time.doubleValue() / totalScheduledHours.doubleValue());
        salida = salida.multiply(new java.math.BigDecimal(100));
        salida = salida.setScale(2, java.math.BigDecimal.ROUND_DOWN);
        }*/

        return salida;
    }

    /* Se obtiene el rendimiento de esta tarea, el cual viene dado por la formula
     *   (Tiempo_Estimado/Tiempo_Actual) * 100.
     *   Si Tiempo_Actual = 0 implica que el rendimiento es 0
     */
    public java.math.BigDecimal getPerformanceUsingLoad() {
        java.math.BigDecimal salida = new BigDecimal(0);
        // Para evitar una division por 0

        try {
            if (this.totalCalendarTime == 0) {
                salida = new java.math.BigDecimal(0);
            } else {
                salida = new java.math.BigDecimal(new BigDecimal(totalCalendarTime).doubleValue() /
                        estimated_time.doubleValue());

                salida = salida.multiply(new java.math.BigDecimal(100));
                salida = salida.setScale(2, java.math.BigDecimal.ROUND_DOWN);
            }

            return salida;
        } catch (Exception e) {
            return salida;
        }
    }

    // Regresa la diferencia en tiempo entre el real de horario y el de agenda
    public String getVariance() {
        BigDecimal val = new BigDecimal(0);
        String format = "";


        /*Pasa a minutos el totalScheduledHours y el estimated_time
         * para hacer los calculos en minutos
         */
        BigDecimal hour_total = new BigDecimal(0);
        BigDecimal min_total = new BigDecimal(0);
        if (totalScheduledHours.toString().replace('.', ',').split(",").length > 1) {
            String[] split_min = null;
            String replace_min = totalScheduledHours.toString().replace('.', ',');
            split_min = replace_min.split(",");
            hour_total = new BigDecimal(split_min[0]).multiply(new BigDecimal(60));
            min_total = new BigDecimal(split_min[1]);
            if (split_min[1].length() == 1) {
                min_total = min_total.multiply(new BigDecimal(10));
            }
            min_total = min_total.add(hour_total);
        } else {
            min_total = totalScheduledHours.multiply(new BigDecimal(60));
        }
      
        BigDecimal hour_estimated = new BigDecimal(0);
        BigDecimal min_estimated = new BigDecimal(0);
        if (estimated_time.toString().replace('.', ',').split(",").length > 1) {
            String[] split_min_e = null;
            String replace_min_e = estimated_time.toString().replace('.', ',');
            split_min_e = replace_min_e.split(",");
            hour_estimated = new BigDecimal(split_min_e[0]).multiply(new BigDecimal(60));
            min_estimated = new BigDecimal(split_min_e[1]);
            if (split_min_e[1].length() == 1) {
                min_estimated = min_estimated.multiply(new BigDecimal(10));
            }
            min_estimated = min_estimated.add(hour_estimated);
        } else {
            min_estimated = estimated_time.multiply(new BigDecimal(60));
        }
        
        val = min_estimated.subtract(min_total);
        
        String[] split_val = null;
        if (val.toString().startsWith("-")) {
            split_val = val.toString().split("-");
            val = new BigDecimal(split_val[1].toString());
            format = "-";
        }

        boolean band = false;
        BigDecimal valHour = new BigDecimal(0);
        String[] split_min = null;
        String replace_min = "";
        while (!band) {          
            if (val.compareTo(new BigDecimal("59")) == 1) {
                val = val.divide(new BigDecimal(60), 2, BigDecimal.ROUND_UP);
                replace_min = val.toString().replace('.', ',');
                split_min = replace_min.split(",");
                valHour = valHour.add(new BigDecimal(split_min[0]));
                val = new BigDecimal("0." + split_min[1]);
                val = val.multiply(new BigDecimal("60"));
                if (val.toString().replace('.', ',').split(",").length > 1) {
                    replace_min = val.toString().replace('.', ',');
                    split_min = replace_min.split(",");
                    val = new BigDecimal(split_min[0]);
                }
            } else {
                band = true;
            }
        }     
        if (val.toString().length() == 1) {
            format += this.formatRealHour(new BigDecimal(valHour.toString() + ".0" + val.toString()));
        } else {
            format += this.formatRealHour(new BigDecimal(valHour.toString() + "." + val.toString()));
        }
        /*long val = totalScheduledHours.longValue();
        val -= estimated_time.longValue();*/
        return format;
    }
    
    
       public BigDecimal getVariance2() {
        BigDecimal val = new BigDecimal(0);
       
        /*Pasa a minutos el totalScheduledHours y el estimated_time
         * para hacer los calculos en minutos
         */
        BigDecimal hour_total = new BigDecimal(0);
        BigDecimal min_total = new BigDecimal(0);
        if (totalScheduledHours.toString().replace('.', ',').split(",").length > 1) {
            String[] split_min = null;
            String replace_min = totalScheduledHours.toString().replace('.', ',');
            split_min = replace_min.split(",");
            hour_total = new BigDecimal(split_min[0]).multiply(new BigDecimal(60));
            min_total = new BigDecimal(split_min[1]);
            if (split_min[1].length() == 1) {
                min_total = min_total.multiply(new BigDecimal(10));
            }
            min_total = min_total.add(hour_total);
        } else {
            min_total = totalScheduledHours.multiply(new BigDecimal(60));
        }
      
        BigDecimal hour_estimated = new BigDecimal(0);
        BigDecimal min_estimated = new BigDecimal(0);
        if (estimated_time.toString().replace('.', ',').split(",").length > 1) {
            String[] split_min_e = null;
            String replace_min_e = estimated_time.toString().replace('.', ',');
            split_min_e = replace_min_e.split(",");
            hour_estimated = new BigDecimal(split_min_e[0]).multiply(new BigDecimal(60));
            min_estimated = new BigDecimal(split_min_e[1]);
            if (split_min_e[1].length() == 1) {
                min_estimated = min_estimated.multiply(new BigDecimal(10));
            }
            min_estimated = min_estimated.add(hour_estimated);
        } else {
            min_estimated = estimated_time.multiply(new BigDecimal(60));
        }
        
        val = min_estimated.subtract(min_total);
       
        return val;
    }
  


    // Regresa la diferencia en tiempo entre el real de horario y el de agenda
    public long getVarianceLoad() {
        try {
            long val = estimated_time.longValue();
            val -= this.totalCalendarTime;

            return val;
        } catch (Exception e) {
            return 0;
        }
    }

    /* Se obtiene el deficit de esta tarea, que viene a ser
     * 100 - (rendimiento + tolerancia)
     */
    public java.math.BigDecimal getdeficit() {
        java.math.BigDecimal salida = new java.math.BigDecimal(0);

        // Se obtiene el rendimiento
        salida = this.getperformance();

        // Se le agrega la tolerancia.
        salida.add(new java.math.BigDecimal(tolerance));

        salida = new java.math.BigDecimal(100).subtract(salida);

        if (salida.compareTo(new java.math.BigDecimal(0)) == -1) {
            salida = new java.math.BigDecimal(0);
        }

        return salida;
    }

    /* Metodo que indica si para esta tarea es posible enviar o no una cotizacion */
    public boolean canSendQuote() {
        boolean result = false;

        if (this.collect.equals("1") &&
                (this.fare.compareTo(new java.math.BigDecimal(0)) > 0) &&
                this.status == 5 &&
                (this.estimated_time.compareTo(new java.math.BigDecimal(0)) > 0)) {
            result = true;
        }

        return result;
    }

    // Metodo que retorna el costo estimado de esta tarea con base en el miembro
    // asignado
    public String getFormatedEstimatedCost() {
        DecimalFormat n = new DecimalFormat("###,###,###,##0.00");
        double money = 0;

        if (assigned_to > 0) // Se debe omitir el caso de las tareas no asignadas
        {
            money = (this.estimated_time.multiply(parentAssigned.getCost())).doubleValue();
        }

        return n.format(money);
    }

    // Metodo que retorna el costo real de esta tarea con base en el miembro
    // asignado
    public String getFormatedRealCost() {
        DecimalFormat n = new DecimalFormat("###,###,###,##0.00");
        double money = 0;
        if (assigned_to > 0) // Se debe omitir el caso de las tareas no asignadas            
        {
            money = (this.actual_time.multiply(parentAssigned.getCost())).doubleValue();
        }

        return n.format(money);
    }

    // Se regresa el costo estimado de esta tarea
    public BigDecimal getEstimatedCost() {
        if (assigned_to > 0) // Se debe omitir el caso de las tareas no asignadas
        {
            return this.estimated_time.multiply(parentAssigned.getCost());
        } else {
            return new BigDecimal(0);
        }
    }

    // Se regresa el costo real de esta tarea
    public BigDecimal getRealCost() {
        if (assigned_to > 0) // Se debe omitir el caso de las tareas no asignadas
        {
            return this.actual_time.multiply(parentAssigned.getCost());
        } else {
            return new BigDecimal(0);
        }

    }

    public String getFormatedTotalActualCost() {
        DecimalFormat n = new DecimalFormat("###,###,###,##0.00");
        double money = (this.actual_time.multiply(this.getfare())).doubleValue();

        return n.format(money);
    }

    public String getFormatedTotalEstimatedCost() {
        DecimalFormat n = new DecimalFormat("###,###,###,##0.00");
        double money = (this.getestimated_time().multiply(this.getfare())).doubleValue();
        return n.format(money);
    }

    public String toString() {
        return " id: "+id+" description: " + (description == null ? "" : new String(description)) +
                " name: " +name+" assigned_to: "+ (assigned_to == 0 ? "" : parentAssigned.getlogin());
    }

    // Regresa la descripcion en formato HTML
    private String cleanInvalidTags(String source) {
        try {
            StringBuffer temp = new StringBuffer(source);

            // Los tabs tambien       
            int i = temp.indexOf("\\t");
            while (i > 0) {
                temp.replace(i, i + 2, "   ");
                i = temp.indexOf("\\t");
            }

            // Los tabs tambien       
            i = temp.indexOf("\t");
            while (i > 0) {
                temp.replace(i, i + 1, "   ");
                i = temp.indexOf("\t");
            }

            return temp.toString();
        } catch (Exception e) {
            return source;
        }
    }

    /* Se obtiene la varianza de esta tarea:
     * reales - estimado
     */
    public java.math.BigDecimal getvariance() {
        java.math.BigDecimal salida = actual_time.subtract(estimated_time);
        return salida;
    }

    /** Metodo que define el tiempo de calendario que esta tarea tiene registrada
     * y que viene del calculo de cargas
     */
    public void setCalendarTime(int val) {
        totalCalendarTime = val;
    }

    /**
     * Metodo que retorna el tiempo de calendario que esta tarea tiene definida
     */
    public int getCalendarTime() {
        return totalCalendarTime;
    }

    public String formatRealHour(BigDecimal realHour) {
        String auxRealHours = null;
        String replaceRealHours = realHour.toString().replace('.', '-');
        String[] splitRealHours = replaceRealHours.split("-");
        if (splitRealHours.length > 1) {
            if (splitRealHours[1].toString().length() == 1) {
                auxRealHours = splitRealHours[0].toString() + ":" + splitRealHours[1].toString() + "0";
            } else {
                auxRealHours = splitRealHours[0].toString() + ":" + splitRealHours[1].toString();
            }
        } else {
            auxRealHours = splitRealHours[0].toString() + ":00";
        }
        return auxRealHours;
    }

    public int getId_account() {
        return id_account;
    }

    public void setId_account(int id_account) {
        this.id_account = id_account;
    }

    /**
     * @return the start_status_date
     */
    public java.sql.Timestamp getStart_status_date() {
        return start_status_date;
    }

    /**
     * @param start_status_date the start_status_date to set
     */
    public void setStart_status_date(java.sql.Timestamp start_status_date) {
        this.start_status_date = start_status_date;
    }

    /**
     * @return the end_status_date
     */
    public java.sql.Timestamp getEnd_status_date() {
        return end_status_date;
    }

    /**
     * @param end_status_date the end_status_date to set
     */
    public void setEnd_status_date(java.sql.Timestamp end_status_date) {
        this.end_status_date = end_status_date;
    }

    /**
     * @return the end_client_status_date
     */
    public java.sql.Timestamp getEnd_client_status_date() {
        return end_client_status_date;
    }

    /**
     * @param end_client_status_date the end_client_status_date to set
     */
    public void setEnd_client_status_date(java.sql.Timestamp end_client_status_date) {
        this.end_client_status_date = end_client_status_date;
    }

        // Regresa la fecha de entrega formateada de forma apropiada.
    public String getFormatedStartStatusDate() {
        try {
            java.text.DateFormat df = java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM);
            return df.format(this.start_status_date);
        } catch (Exception e) {
            return "";
        }

    }

        // Regresa la fecha de entrega formateada de forma apropiada.
    public String getFormatedEndStatusDate() {
        try {
            java.text.DateFormat df = java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM);
            return df.format(this.end_status_date);
        } catch (Exception e) {
            return "";
        }

    }

        // Regresa la fecha de entrega formateada de forma apropiada.
    public String getFormatedEndClientStatusDate() {
        try {
            java.text.DateFormat df = java.text.DateFormat.getDateInstance(java.text.DateFormat.MEDIUM);
            return df.format(this.end_client_status_date);
        } catch (Exception e) {
            return "";
        }

    }

    /**
     * @return the hasErrors
     */
    public boolean getHasErrors() {
        return hasErrors;
    }

    /**
     * @param hasErrors the hasErrors to set
     */
    public void setHasErrors(boolean hasErrors) {
        this.hasErrors = hasErrors;
    }

    /**
     * @return the emailNotifyTQA
     */
    public int getEmailNotifyTQA() {
        return emailNotifyTQA;
    }

    /**
     * @param emailNotifyTQA the emailNotifyTQA to set
     */
    public void setEmailNotifyTQA(int emailNotifyTQA) {
        this.emailNotifyTQA = emailNotifyTQA;
    }

    /**
     * @return the emailNotifyFQA
     */
    public int getEmailNotifyFQA() {
        return emailNotifyFQA;
    }

    /**
     * @param emailNotifyFQA the emailNotifyFQA to set
     */
    public void setEmailNotifyFQA(int emailNotifyFQA) {
        this.emailNotifyFQA = emailNotifyFQA;
    }

    public int getVersion_control() {
        return version_control;
    }

    public void setVersion_control(int version_control) {
        this.version_control = version_control;
    }

    public int getOperation_number() {
        return operation_number;
    }

    public void setOperation_number(int operation_number) {
        this.operation_number = operation_number;
    }
    
    
    
 

}
