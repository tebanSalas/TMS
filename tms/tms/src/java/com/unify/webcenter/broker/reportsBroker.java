//   Generated by FlechaRoja Tech Tools (2003) 
package com.unify.webcenter.broker;

import com.unify.webcenter.data.*;
import com.unify.webcenter.tools.connectionClass;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import org.apache.ojb.broker.query.*;
import org.apache.ojb.broker.*;
import java.util.*;
import java.sql.Timestamp;
import java.util.ArrayList;

/**
 * Class that represent the broker for the table reports
 * @author Administrator
 */
public class reportsBroker extends MainBroker {

    public java.util.Iterator getList(int accountId) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", new Integer(accountId));
        // Query of all the reports
        Query query = new QueryByCriteria(reportsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result to print each Service
        return allLines.iterator();
    }

    public java.util.Iterator getList(String sortColumnName, String sortOrder) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        // Query of all the assignments
        Query query = new QueryByCriteria(reportsData.class, criteria);
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        // now iterate over the result 
        return allLines.iterator();
    }

    public java.util.Iterator getList(String sortColumnName, String sortOrder, int accountId) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        criteria.addEqualTo("id_account", new Integer(accountId));
        // Query of all the reports
        Query query = new QueryByCriteria(reportsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result 
        return allLines.iterator();
    }

    // Return the object associated with the key.
    public mainData getData(int id, int idAccount) {

        reportsData data = new reportsData();

        Criteria criteria = new Criteria();

        criteria.addEqualTo("id", new Integer(id));

        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // Query of the exact organization

        Query query = new QueryByCriteria(reportsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // If exists the record -MUST EXISTS ALWAYS

        if (e.hasNext()) {
            data = (reportsData) e.next();
        }



        // We return the object

        return data;

    }

    // Return the object associated with the key.
    public mainData getData(int id) {

        reportsData data = new reportsData();

        Criteria criteria = new Criteria();

        criteria.addEqualTo("id", new Integer(id));


        // Query of the exact organization

        Query query = new QueryByCriteria(reportsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // If exists the record -MUST EXISTS ALWAYS

        if (e.hasNext()) {
            data = (reportsData) e.next();
        }



        // We return the object

        return data;

    }

    /* Regresa una lista de todas las tareas asociadas con el miembro especificado */
    /*	public java.util.Iterator getListByMember(String sortColumnName, 
    String sortOrder, int idMember, int page) throws PersistenceBrokerException {
    // New criteria for sortering
    Criteria criteria = new Criteria();
    // We order the result set
    if (sortOrder.equalsIgnoreCase("ASC"))
    criteria.addOrderByAscending(sortColumnName);
    else
    criteria.addOrderByDescending(sortColumnName);
    // Se agrega el criteria por proyecto.
    criteria.addEqualTo("owner", Integer.valueOf("" + idMember));                             
    // Query of all the tasks
    Query query = new QueryByCriteria(reportsData.class, criteria);
    // Se setea el total de rows con base en el criteria original
    //setTotalRows(criteria);             
    // ask the broker to retrieve the Extent collection
    Collection allLines = broker.getCollectionByQuery(query);            
    // Se modifica el total de registros retornados para efectos
    // del paginado.
    setCount(new Integer(allLines.size())); 
    if (page > 0 ) {
    // Se determinan los limites superior e inferior
    int inicio = (page-1) * GAP_SIZE;
    int fin = page * GAP_SIZE;
    // now iterate over the result 
    return getCollection(allLines, inicio, fin);
    } else {
    return allLines.iterator();               
    }
    }        
     */
    /* Regresa una lista de todas las tareas asociadas con el miembro especificado */
    public java.util.Iterator getListByMember(String sortColumnName,
            String sortOrder, int idMember, int page, int accountId) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }


        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("owner", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", new Integer(accountId));

        // Query of all the tasks
        Query query = new QueryByCriteria(reportsData.class, criteria);


        // Se setea el total de rows con base en el criteria original
        //setTotalRows(criteria);             
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 

            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }


    }


    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTasks(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            Timestamp startDate1, Timestamp startDate2, String indFechaFinRango,
            Timestamp dueDate1, Timestamp dueDate2,
            String indFechaEndRango, Timestamp endDate1, Timestamp endDate2,
            String sortColumnName, String sortOrder,
            String spreadFix, int idAccount, int page, String chargeable, String published) {
        System.out.println(sortColumnName);
        // Variable temporal
        ArrayList lista = new ArrayList();
        // Se forma un criteria.
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {

            criteria.addOrderByDescending(sortColumnName);
        }


        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(projects);
            criteria.addIn("project", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (members[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(members);
            criteria.addIn("assigned_to", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de prioridades
        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(priorities);
            criteria.addIn("priority", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(status);
            criteria.addIn("status", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(typeTasks);
            criteria.addIn("type_task", lista);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("start_date", startDate1);
            criteria.addLessOrEqualThan("start_date", startDate2);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFechaFinRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("due_date", dueDate1);
            criteria.addLessOrEqualThan("due_date", dueDate2);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFechaEndRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("real_due_date", endDate1);
            criteria.addLessOrEqualThan("real_due_date", endDate2);
        }

        if (spreadFix.equalsIgnoreCase("ALL") == false) {
            criteria.addEqualTo("spread_fix", spreadFix);
        }
        
        if (chargeable != null){
            if (chargeable.equalsIgnoreCase("ALL") == false) {
            criteria.addLike("collect", chargeable);
            }
        }
        
        if (published != null){
            if (published.equalsIgnoreCase("ALL") == false) {
            criteria.addLike("published", published);
            }
        }
        
        // Se extraen todas las tareas que satisfagan los criterios especificados
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        if (page > 0) {

            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * 450;
            int fin = page * 450;


            // now iterate over the result 

            return getCollection(allLines, inicio, fin);

        } else {
            // now iterate over the result
            return allLines.iterator();

        }
    }

    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTasksWithoutPaging(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            Timestamp startDate1, Timestamp startDate2, String indFechaFinRango,
            Timestamp dueDate1, Timestamp dueDate2,
            String indFechaEndRango, Timestamp endDate1, Timestamp endDate2,
            String sortColumnName, String sortOrder,
            String spreadFix, int idAccount, String chargeable, String published) {

        // Variable temporal
        ArrayList lista = new ArrayList();

        // Se forma un criteria.
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(projects);
            criteria.addIn("project", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (members[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(members);
            criteria.addIn("assigned_to", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de prioridades
        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(priorities);
            criteria.addIn("priority", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(status);
            criteria.addIn("status", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(typeTasks);
            criteria.addIn("type_task", lista);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("start_date", startDate1);
            criteria.addLessOrEqualThan("start_date", startDate2);
            System.out.println(" * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFechaFinRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("due_date", dueDate1);
            criteria.addLessOrEqualThan("due_date", dueDate2);
            System.out.println(" * " + indFechaFinRango + " " + dueDate1 + " " + dueDate2);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFechaEndRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("real_due_date", endDate1);
            criteria.addLessOrEqualThan("real_due_date", endDate2);
        }

        if (spreadFix.equalsIgnoreCase("ALL") == false) {
            criteria.addEqualTo("spread_fix", spreadFix);
        }
        
        if (chargeable != null ){
            if (chargeable.equalsIgnoreCase("ALL") == false) {
            criteria.addLike("collect", chargeable);
            }
        }
        
        if (published != null ){
            if (published.equalsIgnoreCase("ALL") == false) {
            criteria.addLike("published", published);
            }
        }
        // Se extraen todas las tareas que satisfagan los criterios especificados
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result 
        return allLines.iterator();
    }

    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTasks(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2, String indFechaFinRango,
            String dueDate1, String dueDate2,
            String indFechaEndRango, String endDate1, String endDate2,
            String sortColumnName, String sortOrder,
            String spreadFix, int idAccount, int page, String chargeable, String published) {

        Timestamp ini1 = null;
        Timestamp ini2 = null;
        Timestamp ini3 = null;
        Timestamp fin1 = null;
        Timestamp fin2 = null;
        Timestamp fin3 = null;


        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            if (startDate1.indexOf("12:00") < 0) {
                ini1 = Timestamp.valueOf(startDate1 + " 12:00:00.00");
                fin1 = Timestamp.valueOf(startDate2 + " 12:00:00.00");
            } else {
                ini1 = Timestamp.valueOf(startDate1);
                fin1 = Timestamp.valueOf(startDate2);
            }
        }
        // Si se especifica un rango de fechas de inicio
        if (indFechaFinRango.equalsIgnoreCase("ALL") == false) {
            if (dueDate1.indexOf("12:00") < 0) {
                ini2 = Timestamp.valueOf(dueDate1 + " 12:00:00.00");
                fin2 = Timestamp.valueOf(dueDate2 + " 12:00:00.00");
            } else {
                ini2 = Timestamp.valueOf(dueDate1);
                fin2 = Timestamp.valueOf(dueDate2);
            }
        }

        // Si se especifica un rango de fechas de inicio
        if (indFechaEndRango.equalsIgnoreCase("ALL") == false) {
            if (endDate1.indexOf("12:00") < 0) {
                ini3 = Timestamp.valueOf(endDate1 + " 12:00:00.00");
                fin3 = Timestamp.valueOf(endDate2 + " 12:00:00.00");
            } else {
                ini3 = Timestamp.valueOf(endDate1);
                fin3 = Timestamp.valueOf(endDate2);
            }
        }

        return this.getReportByTasks(projects, members, priorities,
                status, typeTasks, indFecInicioRango, ini1, fin1,
                indFechaFinRango, ini2, fin2,
                indFechaEndRango, ini3, fin3,
                sortColumnName, sortOrder,
                spreadFix, idAccount, page, chargeable, published);

    }

    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTasksWithoutPaging(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2, String indFechaFinRango,
            String dueDate1, String dueDate2,
            String indFechaEndRango, String endDate1, String endDate2,
            String sortColumnName, String sortOrder,
            String spreadFix, int idAccount, String chargeable, String published) {

        Timestamp ini1 = null;
        Timestamp ini2 = null;
        Timestamp ini3 = null;
        Timestamp fin1 = null;
        Timestamp fin2 = null;
        Timestamp fin3 = null;

        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            if (startDate1.indexOf("12:00") < 0) {
                ini1 = Timestamp.valueOf(startDate1 + " 12:00:00.00");
                fin1 = Timestamp.valueOf(startDate2 + " 12:00:00.00");
            } else {
                ini1 = Timestamp.valueOf(startDate1);
                fin1 = Timestamp.valueOf(startDate2);
            }
        }

        // Si se especifica un rango de fechas de inicio
        if (indFechaFinRango.equalsIgnoreCase("ALL") == false) {
            if (dueDate1.indexOf("12:00") < 0) {
                ini2 = Timestamp.valueOf(dueDate1 + " 12:00:00.00");
                fin2 = Timestamp.valueOf(dueDate2 + " 12:00:00.00");
            } else {
                ini2 = Timestamp.valueOf(dueDate1);
                fin2 = Timestamp.valueOf(dueDate2);
            }
        }

        // Si se especifica un rango de fechas de inicio
        if (indFechaEndRango.equalsIgnoreCase("ALL") == false) {
            if (endDate1.indexOf("12:00") < 0) {
                ini3 = Timestamp.valueOf(endDate1 + " 12:00:00.00");
                fin3 = Timestamp.valueOf(endDate2 + " 12:00:00.00");
            } else {
                ini3 = Timestamp.valueOf(endDate1);
                fin3 = Timestamp.valueOf(endDate2);
            }
        }

        return this.getReportByTasksWithoutPaging(projects, members, priorities,
                status, typeTasks, indFecInicioRango, ini1, fin1,
                indFechaFinRango, ini2, fin2,
                indFechaEndRango, ini3, fin3,
                sortColumnName, sortOrder,
                spreadFix, idAccount, chargeable, published);

    }

//    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTask2(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2,
            String sortColumnName, String sortOrder,
            String query, int idAccount, int page, String chargeable) {

        // Variable temporal
        ArrayList lista = new ArrayList();
        // Se forma un criteria.
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        criteria.addEqualTo("parentTask.id_account", Integer.valueOf("" + idAccount));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (members[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(members);
            criteria.addIn("parentTask.assigned_to", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(projects);
            criteria.addIn("parentTask.project", lista);
        }

        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(priorities);
            criteria.addIn("parentTask.priority", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(status);
            criteria.addIn("parentTask.status", lista);
        }
        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(typeTasks);
            criteria.addIn("parentTask.type_task", lista);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("day", startDate1);
            criteria.addLessOrEqualThan("day", startDate2);
        }

        criteria.addLike("parentTask.name", query);
        
        if (chargeable.equalsIgnoreCase("ALL") == false) {
        criteria.addLike("collect", chargeable);
        }
        // Se extraen todas las tareas que satisfagan los criterios especificados
        Query query2 = new QueryByCriteria(schedulesData.class, criteria);
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query2);
        // now iterate over the result 
        if (page > 0) {

            // Se determinan los limites superior e inferior

            int inicio = (page - 1) * 450;

            int fin = page * 450;



            // now iterate over the result 

            return getCollection(allLines, inicio, fin);

        } else {

            return allLines.iterator();

        }
    }

    //    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTask2(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2,
            String sortColumnName, String sortOrder,
            String query, int idAccount, String chargeable) {
        

        // Variable temporal
        ArrayList lista = new ArrayList();

        // Se forma un criteria.
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        criteria.addEqualTo("parentTask.id_account", Integer.valueOf("" + idAccount));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (members[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(members);
            criteria.addIn("parentTask.assigned_to", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(projects);
            criteria.addIn("parentTask.project", lista);
        }

        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(priorities);
            criteria.addIn("parentTask.priority", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(status);
            criteria.addIn("parentTask.status", lista);
        }
        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(typeTasks);
            criteria.addIn("parentTask.type_task", lista);
        }
        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("day", startDate1);
            criteria.addLessOrEqualThan("day", startDate2);
        }

        if (chargeable.equalsIgnoreCase("ALL") == false) {
        criteria.addLike("collect", chargeable);
        }
        
        System.out.println("PARENT TASK: " + query);
        criteria.addLike("parentTask.name", query);
        // Se extraen todas las tareas que satisfagan los criterios especificados
        Query query2 = new QueryByCriteria(schedulesData.class, criteria);
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query2);
        // now iterate over the result 

        return allLines.iterator();


    }
    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */

    public java.util.Iterator getReportByTask4(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2,
            String sortColumnName, String sortOrder,
            String query, int idAccount) {

        // Variable temporal
        ArrayList lista = new ArrayList();

        // Se forma un criteria.
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (members[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(members);
            criteria.addIn("assigned_to", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(projects);
            criteria.addIn("project", lista);
        }

        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(priorities);
            criteria.addIn("priority", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(status);
            criteria.addIn("status", lista);
        }
        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(typeTasks);
            criteria.addIn("type_task", lista);
        }
        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("day", startDate1);
            criteria.addLessOrEqualThan("day", startDate2);
        }

        criteria.addLike("name", query);
        // Se extraen todas las tareas que satisfagan los criterios especificados
        Query query2 = new QueryByCriteria(tasksData.class, criteria);
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query2);
        // now iterate over the result 
        return allLines.iterator();
    }
         /* Regresa una lista de todas los proyectos asociadas con member especificado */
    public ArrayList getProjectReporteGastos(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2,
            String sortColumnName, String sortOrder,
            String query, int idAccount, String cobrable) throws PersistenceBrokerException {
        
        Connection conn = null;
        ResultSet rs = null;
        Statement stmt1 = null;
        projectsData projData= new projectsData();
        ArrayList projectsList= new ArrayList();
        //Hashtable hashProjects = new Hashtable();
        String query_str="";
        query_str="SELECT distinct projects.id , projects.name from tasks, projects ";
        query_str=query_str+"WHERE tasks.id_account="+ idAccount+" AND tasks.project= projects.id ";
        
        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.type_task IN (";
            for (int i = 0; i<typeTasks.length; i++){
                if (i!= typeTasks.length-1){
                query_str= query_str+typeTasks[i]+",";
                }else
                query_str= query_str+typeTasks[i]+")";
            }
        }


        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.project IN (";
            for (int i = 0; i<projects.length; i++){
                if (i!= projects.length-1){
                query_str= query_str+projects[i]+",";
                }else
                query_str= query_str+projects[i]+")";
            }
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (members[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.assigned_to IN (";
            for (int i = 0; i<members.length; i++){
                if (i!= members.length-1){
                query_str= query_str+members[i]+",";
                }else
                query_str= query_str+members[i]+")";
            }
            //members
        }

        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.priority IN (";
            for (int i = 0; i<priorities.length; i++){
                if (i!= priorities.length-1){
                query_str= query_str+priorities[i]+",";
                }else
                query_str= query_str+priorities[i]+")";
            }
            //priorities);
        }


        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.status IN (";
            for (int i = 0; i<status.length; i++){
                if (i!= status.length-1){
                query_str= query_str+status[i]+",";
                }else
                query_str= query_str+status[i]+")";
            }
            //status);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND to_date(schedules.day, 'YYYY-MM-DD') >=";
            query_str= query_str+ "to_date('"+startDate1+"','YYYY-MM-DD') AND"; 
            query_str= query_str+ " to_date(schedules.day, 'YYYY-MM-DD') <=";
            query_str= query_str+ "to_date('"+startDate2+"','YYYY-MM-DD')"; 
            System.out.println(" * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        }
        if (cobrable.equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.collect= "+ cobrable;
        }
        
        query_str= query_str+" AND tasks.name LIKE '"+query+"'";
        
         System.out.println("SENTENCIA SQL Reporte Gastos: "+query_str);
        connectionClass _conecctionClass = new connectionClass();
        conn = _conecctionClass.getConnection();
        try {             
            stmt1 = conn.createStatement();
            rs = stmt1.executeQuery(query_str);
              while (rs.next()) {
                projData= new projectsData();
                projData.setid(rs.getInt("id"));
                projData.setname(rs.getString("name"));
                projData.setId_account(idAccount);
                
                projectsList.add(projData);
            
              }
        } catch (SQLException ex) {
            ex.printStackTrace();
              try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
        }
        
            try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
        
        
        return projectsList;
    }
    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
public java.util.Iterator getReportByTask3(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2,
            String sortColumnName, String sortOrder,
            String query, int idAccount, String cobrable) {
        // Variable temporal
        ArrayList lista = new ArrayList();

        System.out.println("1 * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        // Se forma un criteria.
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        System.out.println("2 * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        System.out.println("3 * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (members[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(members);
            criteria.addIn("id", lista);
        }

        System.out.println("4 * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(projects);
            criteria.addIn("project", lista);
        }

        System.out.println("5 * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(priorities);
            criteria.addIn("priority", lista);
        }

        System.out.println("6 * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(status);
            criteria.addIn("status", lista);
        }
        // Si en la lista no viene ningun ALL, se agrega el criterio de status

        System.out.println("7 * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(typeTasks);
            criteria.addIn("type_task", lista);
        }

        System.out.println("8 * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        // Si se especifica un rango de fechas de inicio


        // Si se especifica un rango de fechas de inicio

        if (startDate1 != null && startDate2 != null) {
            startDate1 = startDate1.replace(':', '-') + " 00:00:00.000000000";
            startDate2 = startDate2.replace(':', '-') + " 00:00:00.000000000";
            System.out.println(" * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
            if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
                criteria.addGreaterOrEqualThan("start_date", startDate1);
                criteria.addLessOrEqualThan("start_date", startDate2);
                System.out.println("9 * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
            }
        }
        if (cobrable.equalsIgnoreCase("ALL") == false) {
            criteria.addLike("collect", cobrable);
        }


        criteria.addLike("name", query);
        // Se extraen todas las tareas que satisfagan los criterios especificados

        Query query2 = new QueryByCriteria(tasksData.class, criteria);
        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query2);
        // now iterate over the result
        return allLines.iterator();
    }


    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTasks2(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2,
            String sortColumnName, String sortOrder,
            String query, int idAccount, int page, String chargeable) {


        return this.getReportByTask2(projects, members, priorities,
                status, typeTasks, indFecInicioRango, startDate1, startDate2,
                sortColumnName, sortOrder,
                query, idAccount, page, chargeable);

    }
    
       /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTickets(String[] projects, String projStatus, String tickStatus,
            String sortColumnName, String sortOrder,
            String query, int idAccount, int page) {

        return this.getReportByTicket(projects, projStatus, tickStatus,
                sortColumnName, sortOrder,
                query, idAccount, page);

    }
    
     //    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTicket(String[] projects, String projStatus,
             String tickStatus, String sortColumnName, String sortOrder,
            String query, int idAccount, int page) {
        
         String status[];
  
        if (projStatus.equals("1")){
            status= new String[2];
            status[0]="1"; // Finalizado --> No Activo 
            status[1]="4";// Suspendido --> No Activo 
        }else if (projStatus.equals("0")){
            status= new String[3];
            status[0]="2";
            status[1]="3";
            status[2]="5"; 
        }else{
            status= new String[5];
        status[0]="1"; // Finalizado --> No Activo 
        status[1]="2";
        status[2]="3";
        status[3]="4";// Suspendido --> No Activo 
        status[4]="5";
        }
       
                
            
        // Se forma un criteria.
        Criteria criteria = new Criteria();
        // Variable temporal
        ArrayList lista = new ArrayList();
        ArrayList statusList = new ArrayList();
        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(projects);
            criteria.addIn("project", lista);
        }
        
        if (!tickStatus.equals("2")) 
        criteria.addLike("status", tickStatus);
        
       statusList = this.convertToArray(status);
        if(!projStatus.equals("2"))
        criteria.addIn("parentProject.status",statusList);
        
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        
         // Se extraen todas las tareas que satisfagan los criterios especificados

        Query query2 = new QueryByCriteria(topicsData.class, criteria);
        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query2);
                // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));
        // now iterate over the result
        if (page > 0) {

            // Se determinan los limites superior e inferior

            int inicio = (page - 1) * 450;

            int fin = page * 450;



            // now iterate over the result 

            return getCollection(allLines, inicio, fin);

        } else {

            return allLines.iterator();

        }
        
    }
    
    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTasksWithhoutPaging(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2,
            String sortColumnName, String sortOrder,
            String query, int idAccount, String chargeable) {


        return this.getReportByTask2(projects, members, priorities,
                status, typeTasks, indFecInicioRango, startDate1, startDate2,
                sortColumnName, sortOrder,
                query, idAccount, chargeable);

    }

    public java.util.Iterator getReportCosts(String sortColumnName, String sortOrder,
            int idAccount, String cobrable) {

        // Variable temporal
        ArrayList lista = new ArrayList();

        // Se forma un criteria.
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros


        if (cobrable.equalsIgnoreCase("ALL") == false) {
            criteria.addLike("chargeable", cobrable);
        }

        // Se extraen todas las tareas que satisfagan los criterios especificados

        Query query2 = new QueryByCriteria(costsData.class, criteria);
        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query2);
        // now iterate over the result
        return allLines.iterator();
    }

    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTasksForPortal(String[] project, String[] members,
            String[] priorities, String[] status, String indFecInicioRango,
            String startDate1, String startDate2, String indFechaFinRango,
            String dueDate1, String dueDate2, int idAccount, String dueDate3, String dueDate4,
            String indFecInicioRango2) {



        Timestamp ini1 = null;

        Timestamp ini2 = null;

        Timestamp ini3 = null;

        Timestamp fin1 = null;

        Timestamp fin2 = null;

        Timestamp fin3 = null;


        // Si se especifica un rango de fechas de inicio

        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {

            if (startDate1.indexOf("12:00") < 0) {
                ini1 = Timestamp.valueOf(startDate1 + " 12:00:00.00");

                fin1 = Timestamp.valueOf(startDate2 + " 12:00:00.00");

            } else {
                ini1 = Timestamp.valueOf(startDate1);

                fin1 = Timestamp.valueOf(startDate2);

            }

        }



        // Si se especifica un rango de fechas de inicio

        if (indFechaFinRango.equalsIgnoreCase("ALL") == false) {

            if (dueDate1.indexOf("12:00") < 0) {

                ini2 = Timestamp.valueOf(dueDate1 + " 12:00:00.00");

                fin2 = Timestamp.valueOf(dueDate2 + " 12:00:00.00");

            } else {

                ini2 = Timestamp.valueOf(dueDate1);

                fin2 = Timestamp.valueOf(dueDate2);

            }

        }


                System.out.println(dueDate3);
                System.out.println(dueDate4);

        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango2.equalsIgnoreCase("SF") == false){
        if (indFecInicioRango2.equalsIgnoreCase("ALL") == false) {

            if (dueDate3.indexOf("12:00") < 0) {
                ini3 = Timestamp.valueOf(dueDate3 + " 12:00:00.00");

                fin3 = Timestamp.valueOf(dueDate4 + " 12:00:00.00");

            } else {

                ini3 = Timestamp.valueOf(dueDate3);

                fin3 = Timestamp.valueOf(dueDate4);

            }

        }
        }

        return this.getReportByTasksForPortal(project, members, priorities,
                status, indFecInicioRango, ini1, fin1,
                indFechaFinRango, ini2, fin2, idAccount, ini3, fin3, indFecInicioRango2);
    }

    //* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getReportByTasksForPortal(String[] projects, String[] members,
            String[] priorities, String[] status, String indFecInicioRango,
            Timestamp startDate1, Timestamp startDate2, String indFechaFinRango,
            Timestamp dueDate1, Timestamp dueDate2, int idAccount,
            Timestamp dueDate3, Timestamp dueDate4, String indFecInicioRango2) {


        // Variable temporal

        ArrayList lista = new ArrayList();


        // tasksStatusLogBroker tslBroker= new tasksStatusLogBroker();

        // Se forma un criteria.

        Criteria criteria = new Criteria();


        // We order the result set and set the project

        criteria.addOrderByAscending("name");

        if (projects[0].equalsIgnoreCase("ALL") == false) {

            lista = this.convertToArray(projects);

            criteria.addIn("project", lista);

        }



        // Solo publicadas.

        criteria.addEqualTo("published", "1");


        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros

        if (members[0].equalsIgnoreCase("ALL") == false) {

            lista = this.convertToArray(members);

            criteria.addIn("assigned_to", lista);

        }



        // Si en la lista no viene ningun ALL, se agrega el criterio de prioridades

        if (priorities[0].equalsIgnoreCase("ALL") == false) {

            lista = this.convertToArray(priorities);

            criteria.addIn("priority", lista);

        }



        // Si en la lista no viene ningun ALL, se agrega el criterio de status

        if (status[0].equalsIgnoreCase("ALL") == false) {

            lista = this.convertToArray(status);

            criteria.addIn("status", lista);

        }



        // Si se especifica un rango de fechas de inicio

        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {

            criteria.addGreaterOrEqualThan("start_date", startDate1);

            criteria.addLessOrEqualThan("start_date", startDate2);

        }


        // Si se especifica un rango de fechas de inicio

        if (indFechaFinRango.equalsIgnoreCase("ALL") == false) {

            criteria.addGreaterOrEqualThan("due_date", dueDate1);

            criteria.addLessOrEqualThan("due_date", dueDate2);

        }
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        if (indFecInicioRango2.equalsIgnoreCase("SF") == false) {
            if (indFecInicioRango2.equalsIgnoreCase("ALL") != false) {
                criteria.addSql("id IN (SELECT task from TASK_STATUS_LOG )");

            } else {
                criteria.addSql(" id IN (SELECT task from TASK_STATUS_LOG where created between TO_DATE('"+
                        this.toSimpleDateFormat(dueDate3) + "','dd/mm/yyyy') and TO_DATE('" + this.toSimpleDateFormat(dueDate4) + "','dd/mm/yyyy'))");
            }
        }
System.out.println(criteria.toString());
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        // Se forma un criteria.

//        Criteria criteria1 = new Criteria();
//        toSimpleDateFormat
//        lista = this.convertToArray(allLines.);
//        criteria1.
//        tslBroker.getList(idAccount)
        // now iterate over the result 

        return allLines.iterator();

    }

    /* Mtodo que convierte un String[] a un ArrayList */
    private ArrayList convertToArray(String[] lista) {

        ArrayList salida = new ArrayList();

        for (int i = 0; i < lista.length; i++) {

            salida.add(new Integer(Integer.parseInt(lista[i])));

        }



        return salida;

    }

    private void setTotalRows(Criteria criteria) {

        // Se almacena el maximo de registros verdaderos, para ello

        // se procede con un count

        ReportQueryByCriteria q = QueryFactory.newReportQuery(
                reportsData.class, criteria);



        // define the 'columns' of the report

        q.setColumns(new String[]{"count(*)"});

        Iterator iter = broker.getReportQueryIteratorByQuery(q);

        Integer total = new Integer(0);



        if (iter.hasNext()) {

            Object[] arr = (Object[]) iter.next();

            total = (Integer) arr[0];



            // En caso de que sea nulo el resultado, se regresa 0

            if (total == null) {
                total = new Integer(0);
            }

        }



        // Se modifica la variable privada de total

        setCount(total);

    }

    /*
     * Metodo que elimina todas las referencias de un member en todos los reportes.
     */
    public void deleteAllReferences(int memberId, int idAccount) throws PersistenceBrokerException {

        // New criteria for search

        Criteria criteria = new Criteria();



        // Se agrega el criteria por proyecto.

        criteria.addEqualTo("owner", Integer.valueOf("" + memberId));

        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // Query of all the teams

        Query query = new QueryByCriteria(reportsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        Iterator e = allLines.iterator();



        // Se borra cada entrada

        while (e.hasNext()) {

            this.delete(e.next());

        }

    }

    public void deleteAllReferencesbyAccount(int accountId) throws PersistenceBrokerException {

        // New criteria for search

        Criteria criteria = new Criteria();



        // Se agrega el criteria por proyecto.

        criteria.addEqualTo("id_account", Integer.valueOf("" + accountId));



        // Query of all the teams

        Query query = new QueryByCriteria(reportsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        Iterator e = allLines.iterator();



        // Se borra cada entrada

        while (e.hasNext()) {

            this.delete(e.next());

        }

    }
             /* Regresa una lista de todas los proyectos asociadas con member especificado */
    public ArrayList getProjectReportInformeGastos(int idAccount, int idProject,
            String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2,
            String sortColumnName, String sortOrder,
            String query, String cobrable) throws PersistenceBrokerException {
        
        Connection conn = null;
        ResultSet rs = null;
        Statement stmt1 = null;
        projectsData projData= new projectsData();
        tasksData taskData= new tasksData();
        schedulesData schData= new schedulesData();
       // Hashtable hashProjects = new Hashtable();
        ArrayList list= new ArrayList();
       String query_str="SELECT tasks.id,tasks.project,tasks.priority,tasks.status,tasks.message,tasks.owner,tasks.assigned_to,tasks.name,tasks.description,tasks.start_date,tasks.due_date,"+
        "tasks.real_due_date,tasks.estimated_time,tasks.actual_time,tasks.completion,tasks.created,tasks.modified,tasks.assigned,tasks.published,"+
        "tasks.collect,tasks.send_quotation_date,tasks.reply_quotation_date,tasks.reply_quotation_member,tasks.tolerance,tasks.fare,tasks.predecessor,"+
        "tasks.predecessor_required,tasks.severity,tasks.type_task,tasks.spread_fix,tasks.comments,tasks.topic,tasks.id_account"+
" FROM tasks "+
" WHERE tasks.id_account ="+ idAccount +" AND tasks.project ="+ idProject;
       
       
      // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.type_task IN (";
            for (int i = 0; i<typeTasks.length; i++){
                if (i!= typeTasks.length-1){
                query_str= query_str+typeTasks[i]+",";
                }else
                query_str= query_str+typeTasks[i]+")";
            }
        }


        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (members[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.assigned_to IN (";
            for (int i = 0; i<members.length; i++){
                if (i!= members.length-1){
                query_str= query_str+members[i]+",";
                }else
                query_str= query_str+members[i]+")";
            }
            //members
        }

        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.priority IN (";
            for (int i = 0; i<priorities.length; i++){
                if (i!= priorities.length-1){
                query_str= query_str+priorities[i]+",";
                }else
                query_str= query_str+priorities[i]+")";
            }
            //priorities);
        }


        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.status IN (";
            for (int i = 0; i<status.length; i++){
                if (i!= status.length-1){
                query_str= query_str+status[i]+",";
                }else
                query_str= query_str+status[i]+")";
            }
            //status);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND to_date(schedules.day, 'YYYY-MM-DD') >=";
            query_str= query_str+ "to_date('"+startDate1+"','YYYY-MM-DD') AND"; 
            query_str= query_str+ " to_date(schedules.day, 'YYYY-MM-DD') <=";
            query_str= query_str+ "to_date('"+startDate2+"','YYYY-MM-DD')"; 
            System.out.println(" * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        }
        if (cobrable.equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.collect= "+ cobrable;
        }
        
        query_str= query_str+" AND tasks.name LIKE '"+query+"'";
        
        connectionClass _conecctionClass = new connectionClass();
        conn = _conecctionClass.getConnection();
        try {             
            stmt1 = conn.createStatement();
            rs = stmt1.executeQuery(query_str);
              while (rs.next()) {
                taskData= new tasksData();
                schData= new schedulesData();
                taskData.setid(rs.getInt("id"));
                            taskData.setproject(rs.getInt("project"));
                            taskData.setpriority(rs.getInt("priority"));
                            taskData.setstatus (rs.getInt("status"));
                            taskData.setmessage(rs.getInt("message"));
                            taskData.setowner(rs.getInt("owner"));
                            taskData.setassigned_to(rs.getInt("assigned_to"));
                            taskData.setname(rs.getString("name"));
                            taskData.setdescription(rs.getString("description"));
                            taskData.setstart_date(rs.getTimestamp("start_date"));
                            taskData.setdue_date(rs.getTimestamp("due_date"));
                            taskData.setreal_due_date(rs.getTimestamp("real_due_date"));
                            taskData.setestimated_time(rs.getBigDecimal("estimated_time"));
                            taskData.setactual_time(rs.getBigDecimal("actual_time"));
                            taskData.setcompletion(rs.getInt("completion"));
                            taskData.setcreated(rs.getTimestamp("created"));
                            taskData.setmodified(rs.getTimestamp("modified"));
                            taskData.setassigned(rs.getTimestamp("assigned"));
                            taskData.setpublished(rs.getString("published"));
                            taskData.setcollect(rs.getString("collect"));
                            taskData.setsend_quotation_date(rs.getTimestamp("send_quotation_date"));
                            taskData.setreply_quotation_date(rs.getTimestamp("reply_quotation_date"));
                            taskData.setreply_quotation_member(rs.getInt("reply_quotation_member"));
                            taskData.settolerance(rs.getInt("tolerance"));
                            taskData.setfare(rs.getBigDecimal("fare"));
                            taskData.setpredecessor(rs.getInt("predecessor"));
                            taskData.setpredecessor_required(rs.getString("predecessor_required"));
                            taskData.setseverity(rs.getString("severity"));
                            taskData.settype_task(rs.getInt("type_task"));
                            taskData.setspread_fix(rs.getString("spread_fix"));
                            taskData.setcomments(rs.getString("comments"));
                            taskData.settopic(rs.getInt("topic"));
                            taskData.setId_account(rs.getInt("id_account"));
                            
                list.add(taskData);
              }
    } catch (SQLException ex) {
            ex.printStackTrace();
              try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
        }
            try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
              return list;
    
    }
         /* Regresa una lista de todas los proyectos asociadas con member especificado */
    public ArrayList getProjectReportInformeCostos(int idAccount, int idProject,
            String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2,
            String sortColumnName, String sortOrder,
            String query) throws PersistenceBrokerException {
        
        Connection conn = null;
        ResultSet rs = null;
        Statement stmt1 = null;
        projectsData projData= new projectsData();
        tasksData taskData= new tasksData();
        schedulesData schData= new schedulesData();
       // Hashtable hashProjects = new Hashtable();
        ArrayList list= new ArrayList();
        
        String query_str="SELECT tasks.id,tasks.project,tasks.priority,tasks.status,tasks.message,tasks.owner,tasks.assigned_to,tasks.name,tasks.description,tasks.start_date,tasks.due_date,"+
        "tasks.real_due_date,tasks.estimated_time,tasks.actual_time,tasks.completion,tasks.created,tasks.modified,tasks.assigned,tasks.published,"+
        "tasks.collect,tasks.send_quotation_date,tasks.reply_quotation_date,tasks.reply_quotation_member,tasks.tolerance,tasks.fare,tasks.predecessor,"+
        "tasks.predecessor_required,tasks.severity,tasks.type_task,tasks.spread_fix,tasks.comments,tasks.topic,tasks.id_account,"+
" schedules.hourid, schedules.userid, schedules.day, schedules.id_account, schedules.taskid,"+ 
" schedules.comments, schedules.last_update, schedules.hour_start, schedules.hour_end,"+
" schedules.realtime_hours, schedules.realtime_minutes"+
" FROM schedules, tasks "+
" WHERE schedules.taskid= tasks.id AND schedules.id_account= tasks.id_account "+
" AND tasks.id_account ="+ idAccount +" AND tasks.project ="+ idProject;

        
        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.type_task IN (";
            for (int i = 0; i<typeTasks.length; i++){
                if (i!= typeTasks.length-1){
                query_str= query_str+typeTasks[i]+",";
                }else
                query_str= query_str+typeTasks[i]+")";
            }
        }

        System.out.println("Qasdasdr");
        
        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (members[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.assigned_to IN (";
            for (int i = 0; i<members.length; i++){
                if (i!= members.length-1){
                query_str= query_str+members[i]+",";
                }else
                query_str= query_str+members[i]+")";
            }
            //members
        }

        System.out.println("Qasdasdr11");
        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.priority IN (";
            for (int i = 0; i<priorities.length; i++){
                if (i!= priorities.length-1){
                query_str= query_str+priorities[i]+",";
                }else
                query_str= query_str+priorities[i]+")";
            }
            //priorities);
        }


        System.out.println("Qasdasdr22");
        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.status IN (";
            for (int i = 0; i<status.length; i++){
                if (i!= status.length-1){
                query_str= query_str+status[i]+",";
                }else
                query_str= query_str+status[i]+")";
            }
            //status);
        }

        System.out.println("Qasdasdr33");
        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND to_date(schedules.day, 'YYYY-MM-DD') >=";
            query_str= query_str+ "to_date('"+startDate1+"','YYYY-MM-DD') AND"; 
            query_str= query_str+ " to_date(schedules.day, 'YYYY-MM-DD') <=";
            query_str= query_str+ "to_date('"+startDate2+"','YYYY-MM-DD')"; 
            System.out.println(" * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        }
        System.out.println("Qasdasdr44");
        query_str= query_str+" AND tasks.name LIKE '"+query+"'";
        
        
        System.out.println("QUERY NUEVO #1"+query_str);
        System.out.println("SENTENCIA SQL #2: "+query_str);
        connectionClass _conecctionClass = new connectionClass();
        conn = _conecctionClass.getConnection();
        try {             
            stmt1 = conn.createStatement();
            rs = stmt1.executeQuery(query_str);
              while (rs.next()) {
                taskData= new tasksData();
                schData= new schedulesData();
                taskData.setid(rs.getInt("id"));
                            taskData.setproject(rs.getInt("project"));
                            taskData.setpriority(rs.getInt("priority"));
                            taskData.setstatus (rs.getInt("status"));
                            taskData.setmessage(rs.getInt("message"));
                            taskData.setowner(rs.getInt("owner"));
                            taskData.setassigned_to(rs.getInt("assigned_to"));
                            taskData.setname(rs.getString("name"));
                            taskData.setdescription(rs.getString("description"));
                            taskData.setstart_date(rs.getTimestamp("start_date"));
                            taskData.setdue_date(rs.getTimestamp("due_date"));
                            taskData.setreal_due_date(rs.getTimestamp("real_due_date"));
                            taskData.setestimated_time(rs.getBigDecimal("estimated_time"));
                            taskData.setactual_time(rs.getBigDecimal("actual_time"));
                            taskData.setcompletion(rs.getInt("completion"));
                            taskData.setcreated(rs.getTimestamp("created"));
                            taskData.setmodified(rs.getTimestamp("modified"));
                            taskData.setassigned(rs.getTimestamp("assigned"));
                            taskData.setpublished(rs.getString("published"));
                            taskData.setcollect(rs.getString("collect"));
                            taskData.setsend_quotation_date(rs.getTimestamp("send_quotation_date"));
                            taskData.setreply_quotation_date(rs.getTimestamp("reply_quotation_date"));
                            taskData.setreply_quotation_member(rs.getInt("reply_quotation_member"));
                            taskData.settolerance(rs.getInt("tolerance"));
                            taskData.setfare(rs.getBigDecimal("fare"));
                            taskData.setpredecessor(rs.getInt("predecessor"));
                            taskData.setpredecessor_required(rs.getString("predecessor_required"));
                            taskData.setseverity(rs.getString("severity"));
                            taskData.settype_task(rs.getInt("type_task"));
                            taskData.setspread_fix(rs.getString("spread_fix"));
                            taskData.setcomments(rs.getString("comments"));
                            taskData.settopic(rs.getInt("topic"));
                            taskData.setId_account(rs.getInt("id_account"));
                            
                            schData.sethourid(rs.getInt("hourid"));
                            schData.setuserid(rs.getInt("userid"));
                            schData.setdate(rs.getString("day"));
                            schData.setId_account(rs.getInt("id_account"));
                            schData.settaskid(rs.getInt("taskid"));
                            schData.setcomments(rs.getString("comments"));
                            schData.setHour_start(rs.getString("hour_start"));
                            schData.setHour_end(rs.getString("hour_end"));
                            schData.setRealtime_hours(rs.getInt("realtime_hours"));
                            schData.setRealtime_minutes(rs.getInt("realtime_minutes"));
                            schData.setparentTask(taskData);
                list.add(schData);
              }
    } catch (SQLException ex) {
            ex.printStackTrace();
              try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
        }
        
            try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
              return list;
    
    }
        /* Regresa una lista de todas los proyectos asociadas con member especificado */
    public ArrayList getProjectReportInformeCostos(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2,
            String sortColumnName, String sortOrder,
            String query, int idAccount) throws PersistenceBrokerException {
        
        Connection conn = null;
        ResultSet rs = null;
        Statement stmt1 = null;
        projectsData projData= new projectsData();
        ArrayList projectsList= new ArrayList();
        //Hashtable hashProjects = new Hashtable();
        String query_str="";
        query_str="SELECT distinct projects.id , projects.name from schedules, tasks, projects ";
        query_str=query_str+"WHERE schedules.id_account="+ idAccount+" AND schedules.taskid= tasks.id AND tasks.project= projects.id ";
        
        
        
         // We order the result set
        /*if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }*/

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.type_task IN (";
            for (int i = 0; i<typeTasks.length; i++){
                if (i!= typeTasks.length-1){
                query_str= query_str+typeTasks[i]+",";
                }else
                query_str= query_str+typeTasks[i]+")";
            }
        }


        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.project IN (";
            for (int i = 0; i<projects.length; i++){
                if (i!= projects.length-1){
                query_str= query_str+projects[i]+",";
                }else
                query_str= query_str+projects[i]+")";
            }
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (members[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.assigned_to IN (";
            for (int i = 0; i<members.length; i++){
                if (i!= members.length-1){
                query_str= query_str+members[i]+",";
                }else
                query_str= query_str+members[i]+")";
            }
            //members
        }

        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.priority IN (";
            for (int i = 0; i<priorities.length; i++){
                if (i!= priorities.length-1){
                query_str= query_str+priorities[i]+",";
                }else
                query_str= query_str+priorities[i]+")";
            }
            //priorities);
        }


        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND tasks.status IN (";
            for (int i = 0; i<status.length; i++){
                if (i!= status.length-1){
                query_str= query_str+status[i]+",";
                }else
                query_str= query_str+status[i]+")";
            }
            //status);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            query_str= query_str+ " AND to_date(schedules.day, 'YYYY-MM-DD') >=";
            query_str= query_str+ "to_date('"+startDate1+"','YYYY-MM-DD') AND"; 
            query_str= query_str+ " to_date(schedules.day, 'YYYY-MM-DD') <=";
            query_str= query_str+ "to_date('"+startDate2+"','YYYY-MM-DD')"; 
            System.out.println(" * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        }
        query_str= query_str+" AND tasks.name LIKE '"+query+"'";

        System.out.println("SENTENCIA SQLXX: "+query_str);
        connectionClass _conecctionClass = new connectionClass();
        conn = _conecctionClass.getConnection();
        try {             
            stmt1 = conn.createStatement();
            rs = stmt1.executeQuery(query_str);
              while (rs.next()) {
                projData= new projectsData();
                projData.setid(rs.getInt("id"));
                projData.setname(rs.getString("name"));
                projData.setId_account(idAccount);
                
                projectsList.add(projData);
                //hashProjects.put("" + rs.getInt("id"), projData);
            
              }
        } catch (SQLException ex) {
            ex.printStackTrace();
              try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
        }
        
            try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
              return projectsList;
    }
    
    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados xxd */
    public java.util.Iterator getMasterReportByTasks2(String[] projects, String[] members,
            String[] priorities, String[] status, String[] typeTasks, String indFecInicioRango,
            String startDate1, String startDate2,
            String sortColumnName, String sortOrder,
            String query, int idAccount) {

        // Variable temporal
        ArrayList lista = new ArrayList();

        // Se forma un criteria.
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        criteria.addEqualTo("parentTask.id_account", Integer.valueOf("" + idAccount));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(typeTasks);
            criteria.addIn("type_task", lista);
        }


        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(projects);
            criteria.addIn("parentTask.project", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (members[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(members);
            criteria.addIn("parentTask.assigned_to", lista);
        }

        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(priorities);
            criteria.addIn("parentTask.priority", lista);
        }


        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(status);
            criteria.addIn("parentTask.status", lista);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFecInicioRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("day", startDate1);
            criteria.addLessOrEqualThan("day", startDate2);
            System.out.println(" * " + indFecInicioRango + " " + startDate1 + " " + startDate2);
        }

        criteria.addLike("parentTask.name", query);

        criteria.addOrderByAscending("taskid");
        // Se extraen todas las tareas que satisfagan los criterios especificados
        Query query1 = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query1);
        System.out.println("TAMAO "+allLines.size());
        // now iterate over the result 
        return allLines.iterator();
    }

    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getMasterReportByTasks(String[] projects, int members,
            String[] status, int completionI, int completionF,
            String startDate1, String startDate2, String indFecEntregaRango,
            Timestamp dueDate1, Timestamp dueDate2,
            String indFecFinalRango, Timestamp endDate1, Timestamp endDate2,
            String sortColumnName, String sortOrder,
            int idAccount) {

        // Variable temporal
        ArrayList lista = new ArrayList();

        // Se forma un criteria.
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        criteria.addEqualTo("parentTask.id_account", Integer.valueOf("" + idAccount));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }


        // Si se especifica un rango de fechas de inicio
        criteria.addGreaterOrEqualThan("day", startDate1);
        criteria.addLessOrEqualThan("day", startDate2);

        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(projects);
            criteria.addIn("parentTask.project", lista);
        }

        // se agrega el criterio de miembros
        criteria.addEqualTo("userid", new Integer(members));
        // se agrega el criterio de miembros
        criteria.addEqualTo("parentTask.assigned_to", new Integer(members));

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(status);
            criteria.addIn("parentTask.status", lista);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFecEntregaRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("parentTask.due_date", dueDate1);
            criteria.addLessOrEqualThan("parentTask.due_date", dueDate2);
            System.out.println(" * " + indFecEntregaRango + " " + dueDate1 + " " + dueDate2);
        }

        // Si se especifica un rango de fechas de inicio
        if (indFecFinalRango.equalsIgnoreCase("ALL") == false) {
            criteria.addGreaterOrEqualThan("parentTask.real_due_date", endDate1);
            criteria.addLessOrEqualThan("parentTask.real_due_date", endDate2);
            System.out.println(" * " + indFecFinalRango + " " + endDate1 + " " + endDate2);
        }

        criteria.addGreaterOrEqualThan("parentTask.completion", new Integer(completionI));
        criteria.addLessOrEqualThan("parentTask.completion", new Integer(completionF));
        criteria.addOrderByAscending("taskid");
        // Se extraen todas las tareas que satisfagan los criterios especificados
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result 
        return allLines.iterator();
    }

    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getMasterReportByTasks(String[] projects, int members,
            String[] status, int completionI, int completionF,
            String startDate1, String startDate2, String indFecEntregaRango,
            String dueDate1, String dueDate2,
            String indFecFinalRango, String endDate1, String endDate2,
            String sortColumnName, String sortOrder,
            int idAccount) {

        Timestamp ini1 = null;
        Timestamp ini2 = null;
        Timestamp ini3 = null;
        Timestamp fin1 = null;
        Timestamp fin2 = null;
        Timestamp fin3 = null;

        // Si se especifica un rango de fechas de inicio
   /*     if (startDate1.indexOf("12:00") < 0) {
        ini1 = Timestamp.valueOf(startDate1 + " 12:00:00.00");
        fin1 = Timestamp.valueOf(startDate2 + " 12:00:00.00");
        } else {
        ini1 = Timestamp.valueOf(startDate1);
        fin1 = Timestamp.valueOf(startDate2);
        }*/

        // Si se especifica un rango de fechas de inicio
        if (indFecEntregaRango.equalsIgnoreCase("ALL") == false) {
            if (dueDate1.indexOf("12:00") < 0) {
                ini2 = Timestamp.valueOf(dueDate1 + " 12:00:00.00");
                fin2 = Timestamp.valueOf(dueDate2 + " 12:00:00.00");
            } else {
                ini2 = Timestamp.valueOf(dueDate1);
                fin2 = Timestamp.valueOf(dueDate2);
            }
        }

        // Si se especifica un rango de fechas de inicio
        if (indFecFinalRango.equalsIgnoreCase("ALL") == false) {
            if (endDate1.indexOf("12:00") < 0) {
                ini3 = Timestamp.valueOf(endDate1 + " 12:00:00.00");
                fin3 = Timestamp.valueOf(endDate2 + " 12:00:00.00");
            } else {
                ini3 = Timestamp.valueOf(endDate1);
                fin3 = Timestamp.valueOf(endDate2);
            }
        }

        return this.getMasterReportByTasks(projects, members,
                status, completionI, completionF, startDate1, startDate2,
                indFecEntregaRango, ini2, fin2,
                indFecFinalRango, ini3, fin3,
                sortColumnName, sortOrder,
                idAccount);
    }

    /* Ejecuta el reporte de tareas de acuerdo a los parametros adecuados */
    public java.util.Iterator getMasterReportByTasks(int members,
            String sortColumnName, String sortOrder,
            int idAccount, ArrayList repetidos) {

        // Se forma un criteria.
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // se agrega el criterio de miembros
        criteria.addEqualTo("assigned_to", new Integer(members));
        if (!repetidos.isEmpty()) {
            criteria.addNotIn("id", repetidos);
        }
        ArrayList listStatus = new ArrayList();

        listStatus.add(Integer.valueOf("2"));
        listStatus.add(Integer.valueOf("3"));
        listStatus.add(Integer.valueOf("13"));
        listStatus.add(Integer.valueOf("12"));
        listStatus.add(Integer.valueOf("14"));

        criteria.addIn("status", listStatus);
        criteria.addOrderByAscending("id");
        // Se extraen todas las tareas que satisfagan los criterios especificados
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result 
        return allLines.iterator();
    }

    public String toSimpleDateFormat(Timestamp date) {
        java.text.SimpleDateFormat format = new java.text.SimpleDateFormat("dd/MM/yyyy");

        return format.format(new Date(date.getTime()));
    }
}
