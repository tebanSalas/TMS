//   Generated by FlechaRoja Tech Tools (2003) 
package com.unify.webcenter.broker;

import com.unify.webcenter.data.*;
import com.unify.webcenter.tools.connectionClass;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import org.apache.ojb.broker.query.*;
import org.apache.ojb.broker.*;
import java.util.*;
import java.sql.Timestamp;




import java.util.ArrayList;
import javax.servlet.*;
import javax.servlet.http.*;

/**
 * Class that represent the broker for the table tasks
 * @author Administrator
 */
public class tasksBroker extends MainBroker {

    private static int EXPIRACION_TAREA = 10;

    public java.util.Iterator getList(int accountId) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", new Integer(accountId));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result to print each Service
        return allLines.iterator();
    }

    public java.util.Iterator getList(String sortColumnName, String sortOrder) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        // Query of all the assignments
        Query query = new QueryByCriteria(tasksData.class, criteria);
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        // now iterate over the result 
        return allLines.iterator();
    }

    public java.util.Iterator getList(String sortColumnName, String sortOrder, int accountId) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        criteria.addEqualTo("id_account", new Integer(accountId));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result 
        return allLines.iterator();
    }

    public int getOrganization(int idProject, int idAccount) {
        Criteria criteria = new Criteria();
        projectsData projectsData = new projectsData();
        // Se obtiene el iterador sobre todos los elementos de la lista.
        criteria.addEqualTo("id", Integer.valueOf("" + idProject));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // Debemos convertir el iterador en un arraylist.
        ArrayList lista = new ArrayList();
        Collection allLines = broker.getCollectionByQuery(query);
        Iterator e = allLines.iterator();
        if (e.hasNext()) {
            projectsData = (projectsData) e.next();
        }
        return projectsData.getorganization();
    }


    // Return the object associated with the key.
    public mainData getData(int id, int idAccount) {
        tasksData data = new tasksData();
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id", new Integer(id));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of the exact organization
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        Iterator e = allLines.iterator();
        // If exists the record -MUST EXISTS ALWAYS
        if (e.hasNext()) {
            data = (tasksData) e.next();
        }
        // We return the object
        return data;
    }

    // Return the object associated with the key.
    public mainData getData(int id) {
        tasksData data = new tasksData();
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id", new Integer(id));

        // Query of the exact organization
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        Iterator e = allLines.iterator();
        // If exists the record -MUST EXISTS ALWAYS
        if (e.hasNext()) {
            data = (tasksData) e.next();
        }
        // We return the object
        return data;
    }
    /* Regresa una lista de todas las tareas asociadas con el proyecto especificado */

    public java.util.Iterator getListByProject(String sortColumnName,
            String sortOrder, int idProject, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));





        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));


        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /*  public java.util.Iterator getListByProjectType(String sortColumnName,
    String sortOrder, int idProject, int page, int idAccount, int type) throws PersistenceBrokerException {
    // New criteria for sortering
    Criteria criteria = new Criteria();
    // We order the result set
    if (sortOrder.equalsIgnoreCase("ASC")) {
    criteria.addOrderByAscending(sortColumnName);
    } else {
    criteria.addOrderByDescending(sortColumnName);
    }
    // Se agrega el criteria por proyecto.
    criteria.addEqualTo("project", Integer.valueOf("" + idProject));
    criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
    ArrayList listStatus = new ArrayList();
    switch (type) {
    case 1:
    listStatus.add(Integer.valueOf("2"));
    listStatus.add(Integer.valueOf("3"));
    listStatus.add(Integer.valueOf("12"));
    listStatus.add(Integer.valueOf("13"));
    listStatus.add(Integer.valueOf("14"));
    break;
    case 2:
    listStatus.add(Integer.valueOf("5"));
    listStatus.add(Integer.valueOf("6"));
    listStatus.add(Integer.valueOf("7"));
    listStatus.add(Integer.valueOf("8"));
    break;
    case 3:
    listStatus.add(Integer.valueOf("9"));
    listStatus.add(Integer.valueOf("10"));
    listStatus.add(Integer.valueOf("11"));
    break;
    case 4:
    listStatus.add(Integer.valueOf("0"));
    listStatus.add(Integer.valueOf("1"));
    listStatus.add(Integer.valueOf("4"));
    break;
    }
    criteria.addIn("status", listStatus);
    // Query of all the tasks
    Query query = new QueryByCriteria(tasksData.class, criteria);
    // ask the broker to retrieve the Extent collection
    Collection allLines = broker.getCollectionByQuery(query);
    // Se modifica el total de registros retornados para efectos
    // del paginado.
    setCount(new Integer(allLines.size()));
    if (page > 0) {
    // Se determinan los limites superior e inferior
    int inicio = (page - 1) * GAP_SIZE;
    int fin = page * GAP_SIZE;
    // now iterate over the result 
    return getCollection(allLines, inicio, fin);
    } else {
    return allLines.iterator();
    }
    }
     */
    /* 
    /* Regresa una lista de todas las tareas asociadas con el proyecto especificado */
    public java.util.Iterator getListByProject(String sortColumnName,
            String sortOrder, int idProject, int page) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));


        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa una lista de todas las tareas asociadas con el proyecto especificado 
     * siempre y cuando sean de un tipo particular. Hay 4 tipos:
     *  1. En Proceso  (2,3,4)
     *  2. Cotizaciones (5,6,7,8)
     *  3. Cobros  (9,10,11,12)
     *  4. Finalizadas (0,1)
     */
    public java.util.Iterator getListByProjectByType(String sortColumnName,
            String sortOrder, int idProject, int page, int type, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        // Se agrega el criteria por cuenta.
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Se filtran de acuerdo al tipo q poseen
        ArrayList listStatus = new ArrayList();

        switch (type) {
            case 1:
                listStatus.add(Integer.valueOf("2"));
                listStatus.add(Integer.valueOf("3"));
                listStatus.add(Integer.valueOf("12"));
                listStatus.add(Integer.valueOf("13"));
                listStatus.add(Integer.valueOf("14"));
                listStatus.add(Integer.valueOf("11"));
                listStatus.add(Integer.valueOf("9"));
                listStatus.add(Integer.valueOf("10"));
                break;
            case 2:
                listStatus.add(Integer.valueOf("5"));
                listStatus.add(Integer.valueOf("6"));
                listStatus.add(Integer.valueOf("7"));
                listStatus.add(Integer.valueOf("8"));
                break;

            case 3:
                listStatus.add(Integer.valueOf("9"));
                listStatus.add(Integer.valueOf("10"));
                listStatus.add(Integer.valueOf("11"));
                break;

            case 4:
                listStatus.add(Integer.valueOf("1"));
                listStatus.add(Integer.valueOf("4"));
                break;

            case 5:
                listStatus.add(Integer.valueOf("0"));
                break;
        }
        criteria.addIn("status", listStatus);


        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));


        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa una lista de todas las tareas asociadas con el proyecto especificado */
    public java.util.Iterator getListByProject(int idProject, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        // Se agrega el criteria por Cuenta.
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        return allLines.iterator();
    }

    /* Regresa una lista de todas las tareas asociadas con el proyecto especificado */
    public void getMembersByProject(int idProject, membersBroker brokerMembers, Hashtable hashMembers, int idAccount) throws PersistenceBrokerException {
        teamsData teamData = new teamsData();
        //membersData memberData = new membersData();
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("projects", Integer.valueOf("" + idProject));
        criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(teamsData.class, criteria);
        System.out.println("query del team");
        System.out.println(query);
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        Iterator e = allLines.iterator();
        System.out.println("e");
        System.out.println(e.hasNext());
        while (e.hasNext()) {
            teamData = (teamsData) e.next();

            // Los guardamos en un hash para que elimine de una vez los duplicados.
            hashMembers.put("" + teamData.getmembers(),
                    brokerMembers.getData(teamData.getmembers(), idAccount));


        }
    }

    /* Regresa una lista de todas las tareas asociadas con el proyecto especificado */
    public java.util.Iterator getEndedStartedListByProject(int idProject, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Se filtran de acuerdo al tipo q poseen
        ArrayList listStatus = new ArrayList();

        listStatus.add(Integer.valueOf("1"));
        listStatus.add(Integer.valueOf("3"));
        criteria.addIn("status", listStatus);

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        return allLines.iterator();
    }


    /* Regresa el total de tareas que estan dispuestas para un proyecto dado 
    pero que esten publicadas. */
    public int getTotalTasksPublishedByProject(int idProject, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();


        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se regresa la cantidad de registros
        return allLines.size();
    }

    public int getTotalTasksPublishedByOneProject(int idProject, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);
        System.out.println("QUERY");
        System.out.println(query);

        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);
        return allLines.size();

    // Se regresa la cantidad de registros

    }


    /* Regresa el total de tareas que estan dispuestas para un proyecto dado 
    pero que esten publicadas. */
    public int getTotalTasksOnTimePublishedByProject(int idProject, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        int total = 0;
        // Se extrae cada una
        tasksData data;
        while (e.hasNext()) {
            data = (tasksData) e.next();


            if (data.expired() == false) {
                total++;
            }
        }

        // Se regresa la cantidad de registros
        return total;
    }

    /* Regresa una lista de todas las tareas asociadas con el proyecto especificado 
    excepto la que se indica -para el caso del edit de una tarea*/
    public java.util.Iterator getListByProject(String sortColumnName,
            String sortOrder, int idProject, int notTask, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addNotEqualTo("id", Integer.valueOf("" + notTask));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));


        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa el total de tareas que han sido asignadas en un proyecto dado 
    ya sea que esten publicadas o no. */
    public int getTotalTasksAssignedByProject(int idProject, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        int total = 0;
        // Se extrae cada una
        tasksData data;
        while (e.hasNext()) {
            data = (tasksData) e.next();

            if (data.expired() == false) {
                total++;
            }
        }

        // Se regresa la cantidad de registros
        return total;
    }

    /* Regresa el total de tareas que estan dispuestas para un proyecto dado 
    ya sea que esten publicadas o no. */
    public int getTotalTasksOnTimeByProject(int idProject, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        int total = 0;
        // Se extrae cada una
        tasksData data;
        while (e.hasNext()) {
            data = (tasksData) e.next();

            if (data.expired() == false) {
                total++;
            }
        }

        // Se regresa la cantidad de registros
        return total;
    }

    /* Regresa el total de tareas que estan dispuestas para un proyecto dado 
    ya sea estas esten publicadas o no. */
    public int getTotalTasksByProject(int idProject, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        int total = 0;
        // Se extrae cada una
        tasksData data;
        while (e.hasNext()) {
            data = (tasksData) e.next();

            if (data.expired() == false) {
                total++;
            }
        }

        // Se regresa la cantidad de registros
        return total;
    }

    /* Regresa el total de tareas que estan dispuestas para un usuario dado 
    ya sea estas esten publicadas o no. */
    public int getTotalTasksByMember(int idMember, int idAccount) throws PersistenceBrokerException {


        // Y ahora en las cuales el es el duenno
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("owner", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        return allLines.size();
    }

    /*
    Regresa el total de tareas que estan dispuestas para un proyecto dado 
    ya sea estas esten publicadas o no. 
     * Redisenado por Gerardo Arroyo para incrementar su performance.
     */
    /*
    Regresa el total de tareas que estan dispuestas para un proyecto dado 
    ya sea estas esten publicadas o no. 
     * Redisenado por Gerardo Arroyo para incrementar su performance.
     */
    public mainData getTotalTasksByProjectStatistics(int idProject) throws PersistenceBrokerException {
        // New criteria for sortering
        statisticsData taskInfo = new statisticsData();

        try {
            java.sql.Connection con = broker.serviceConnectionManager().getConnection();
            java.sql.CallableStatement proc = null;
            boolean band = true;
            if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
                proc = con.prepareCall("{call getProjectInfo(?)}");
            } else {
                band = false;
                proc = con.prepareCall("{call getProjectInfo(?,?,?,?,?,?,?)}");
                proc.registerOutParameter(2, java.sql.Types.NUMERIC);
                proc.registerOutParameter(3, java.sql.Types.NUMERIC);
                proc.registerOutParameter(4, java.sql.Types.NUMERIC);
                proc.registerOutParameter(5, java.sql.Types.NUMERIC);
                proc.registerOutParameter(6, java.sql.Types.NUMERIC);
                proc.registerOutParameter(7, java.sql.Types.NUMERIC);
            }
            proc.setInt(1, idProject);
            proc.executeUpdate();
            if (band) {
                // Ejecutar myudr
                ResultSet rs = proc.executeQuery();
                while (rs.next()) {
                    taskInfo.settotaltasks(rs.getInt(1));
                    taskInfo.settotalendedtasks(rs.getInt(2));
                    taskInfo.settotalnotassignedtasks(rs.getInt(3));
                    // Este paso viene dado por lo siguiente:
                    //  Total de Tareas - Tareas No Asignadas - Total Finalizadas
                    taskInfo.settotalassignedtasks(taskInfo.gettotaltasks() -
                            taskInfo.gettotalnotassignedtasks() - taskInfo.gettotalendedtasks());
                    taskInfo.settotalsuspendedtasks(rs.getInt(4));
                    taskInfo.settotalrejectedtasks(rs.getInt(5));
                    taskInfo.settotaldelayedtasks(rs.getInt(6));
                    // Viene dado por:
                    //  Total de Tareas  - Total Concluidas - Total Atrazadas - Total Rechazadas
                    taskInfo.settotalontimetasks(taskInfo.gettotaltasks() - taskInfo.gettotalendedtasks() - taskInfo.gettotaldelayedtasks() - taskInfo.gettotalrejectedtasks());
                    if (taskInfo.gettotalontimetasks() < 0) {
                        taskInfo.settotalontimetasks(0);
                    }
                }
            } else {

                taskInfo.settotaltasks(proc.getInt(2));

                taskInfo.settotalendedtasks(proc.getInt(3));

                taskInfo.settotalnotassignedtasks(proc.getInt(4));

                // Este paso viene dado por lo siguiente:
                //  Total de Tareas - Tareas No Asignadas - Total Finalizadas
                taskInfo.settotalassignedtasks(taskInfo.gettotaltasks() -
                        taskInfo.gettotalnotassignedtasks() - taskInfo.gettotalendedtasks());

                taskInfo.settotalsuspendedtasks(proc.getInt(5));
                taskInfo.settotalrejectedtasks(proc.getInt(6));
                taskInfo.settotaldelayedtasks(proc.getInt(7));
                // Viene dado por:
                //  Total de Tareas  - Total Concluidas - Total Atrazadas - Total Rechazadas
                taskInfo.settotalontimetasks(taskInfo.gettotaltasks() - taskInfo.gettotalendedtasks() - taskInfo.gettotaldelayedtasks() - taskInfo.gettotalrejectedtasks());

                if (taskInfo.gettotalontimetasks() < 0) {
                    taskInfo.settotalontimetasks(0);
                }
            }
            proc.close();
            con.close();
        } catch (Exception lola) {
            System.out.println(lola);
        }
        return taskInfo;
    }

    /*        
    public mainData getTotalTasksByProjectStatistics(int idProject) throws PersistenceBrokerException {
    // New criteria for sortering
    Criteria criteria = new Criteria();
    statisticsData taskInfo = new statisticsData();
    //-----------------------------------------------------------
    // PASO #1. SE DETERMINAN TODAS LAS TAREAS 
    //-----------------------------------------------------------
    // Se agrega el criteria por proyecto.
    criteria.addEqualTo("project", Integer.valueOf("" + idProject));
    ArrayList listStatus = new ArrayList();
    listStatus.add(Integer.valueOf("1"));
    listStatus.add(Integer.valueOf("2"));
    listStatus.add(Integer.valueOf("3"));
    listStatus.add(Integer.valueOf("4"));
    listStatus.add(Integer.valueOf("12"));
    criteria.addIn("status", listStatus);              
    // Empleamos un reporteQuery para sacar los datos que necesitamos.
    ReportQueryByCriteria q = QueryFactory.newReportQuery(
    tasksData.class, criteria);
    // Extraemos un count(*)
    q.setColumns(new String[] { "count(*)"});
    Iterator iter = broker.getReportQueryIteratorByQuery(q);
    taskInfo.settotaltasks(this.getCount(iter).intValue());            
    //-----------------------------------------------------------
    // PASO #2. SE DETERMINAN TODAS LAS TAREAS TERMINADAS
    //-----------------------------------------------------------
    // Se agrega el criteria por proyecto.
    criteria = new Criteria();
    criteria.addEqualTo("project", Integer.valueOf("" + idProject));
    criteria.addEqualTo("status", Integer.valueOf("1"));
    // Empleamos un reporteQuery para sacar los datos que necesitamos.
    q = QueryFactory.newReportQuery(
    tasksData.class, criteria);
    // Extraemos un count(*)
    q.setColumns(new String[] { "count(*)"});
    iter = broker.getReportQueryIteratorByQuery(q);
    taskInfo.settotalendedtasks(this.getCount(iter).intValue());
    //-----------------------------------------------------------
    // PASO #3. SE DETERMINAN TODAS LAS TAREAS NO ASIGNADAS
    //-----------------------------------------------------------
    // Se agrega el criteria por proyecto.
    criteria = new Criteria();
    criteria.addEqualTo("project", Integer.valueOf("" + idProject));
    listStatus = new ArrayList();
    listStatus.add(Integer.valueOf("2"));
    listStatus.add(Integer.valueOf("3"));
    listStatus.add(Integer.valueOf("4"));
    listStatus.add(Integer.valueOf("12"));
    criteria.addIn("status", listStatus);                            
    criteria.addEqualTo("assigned_to", Integer.valueOf("0"));
    // Empleamos un reporteQuery para sacar los datos que necesitamos.
    q = QueryFactory.newReportQuery(
    tasksData.class, criteria);
    // Extraemos un count(*)
    q.setColumns(new String[] { " count(*) "});
    iter = broker.getReportQueryIteratorByQuery(q);
    taskInfo.settotalnotassignedtasks(this.getCount(iter).intValue());
    //-----------------------------------------------------------
    // PASO #4. SE DETERMINAN TODAS LAS TAREAS ASIGNADAS
    //-----------------------------------------------------------
    // Este paso viene dado por lo siguiente:
    //  Total de Tareas - Tareas No Asignadas - Total Finalizadas
    taskInfo.settotalassignedtasks(taskInfo.gettotaltasks() -
    taskInfo.gettotalnotassignedtasks() - taskInfo.gettotalendedtasks());
    //-----------------------------------------------------------
    // PASO #5. SE DETERMINAN TODAS LAS TAREAS SUSPENDIDAS
    //-----------------------------------------------------------
    // Se agrega el criteria por proyecto.
    criteria = new Criteria();
    criteria.addEqualTo("project", Integer.valueOf("" + idProject));
    criteria.addEqualTo("status", Integer.valueOf("4"));            
    // Empleamos un reporteQuery para sacar los datos que necesitamos.
    q = QueryFactory.newReportQuery(
    tasksData.class, criteria);
    // Extraemos un count(*)
    q.setColumns(new String[] { " count(*) "});
    iter = broker.getReportQueryIteratorByQuery(q);
    taskInfo.settotalsuspendedtasks(this.getCount(iter).intValue());
    //-----------------------------------------------------------
    // PASO #6. SE DETERMINAN TODAS LAS TAREAS RECHAZADAS
    //-----------------------------------------------------------
    // Se agrega el criteria por proyecto.
    criteria = new Criteria();
    criteria.addEqualTo("project", Integer.valueOf("" + idProject));
    criteria.addEqualTo("status", Integer.valueOf("12"));            
    // Empleamos un reporteQuery para sacar los datos que necesitamos.
    q = QueryFactory.newReportQuery(
    tasksData.class, criteria);
    // Extraemos un count(*)
    q.setColumns(new String[] { " count(*) "});
    iter = broker.getReportQueryIteratorByQuery(q);
    taskInfo.settotalrejectedtasks(this.getCount(iter).intValue());
    //-----------------------------------------------------------
    // PASO #7. SE DETERMINAN TODAS LAS TAREAS ATRAZADAS
    //-----------------------------------------------------------
    // Se agrega el criteria por proyecto.
    criteria = new Criteria();
    criteria.addEqualTo("project", Integer.valueOf("" + idProject));
    listStatus = new ArrayList();
    listStatus.add(Integer.valueOf("2"));
    listStatus.add(Integer.valueOf("3"));
    listStatus.add(Integer.valueOf("4"));
    listStatus.add(Integer.valueOf("12"));
    criteria.addIn("status", listStatus);                            
    Criteria criteria2 = new Criteria();
    Criteria criteria3 = new Criteria();
    criteria3.addIsNull("due_date");
    criteria2.addLessThan("due_date", new java.sql.Timestamp(
    java.util.Calendar.getInstance().getTimeInMillis()));            
    criteria2.addOrCriteria(criteria3);
    // El or del due date
    criteria.addAndCriteria(criteria2);            
    // Empleamos un reporteQuery para sacar los datos que necesitamos.
    q = QueryFactory.newReportQuery(
    tasksData.class, criteria);
    // Extraemos un count(*)
    q.setColumns(new String[] { " count(*) "});
    iter = broker.getReportQueryIteratorByQuery(q);
    taskInfo.settotaldelayedtasks(this.getCount(iter).intValue());            
    //-----------------------------------------------------------
    // PASO #7. SE DETERMINAN TODAS LAS TAREAS ON TIME
    //-----------------------------------------------------------            
    // Viene dado por:
    //  Total de Tareas  - Total Concluidas - Total Atrazadas
    taskInfo.settotalontimetasks(taskInfo.gettotaltasks() 
    - taskInfo.gettotalendedtasks()
    - taskInfo.gettotaldelayedtasks());
    System.gc();            
    return taskInfo;
    }        
     */
    /* Regresa una lista de todas las tareas asociadas con el miembro especificado */
    public java.util.Iterator getListByMember(String sortColumnName,
            String sortOrder, int idMember, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();


        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        /*    CUANDO EL BUG EN LOS METODOS DE OJB SE ARREGLE, SE DESCOMENTA ESTA PARTE                                
        // Se setea el total de rows con base en el criteria original
        setTotalRows(criteria);
        // La formula de paging es la siguiente
        // Supongamos que la pagina inicial es la 1
        // Entonces: inicio = (page-1) * GAP + (page - 1)
        //           final = (GAP * page) + (page - 1)
        query.setStartAtIndex( ((page-1) * GAP_SIZE) + page - 1  );  
        query.setEndAtIndex( (page * GAP_SIZE) + page - 1);    
         */
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa una lista de todas las tareas asociadas con el miembro especificado 
     * que no sean finalizadas, en cobro o en cotizaciones.
     */
    /*    public java.util.Iterator getListByMemberFiltered(String sortColumnName,
    String sortOrder, int idMember, int page) throws PersistenceBrokerException {
    // New criteria for sortering
    Criteria criteria = new Criteria();
    // We order the result set
    if (sortOrder.equalsIgnoreCase("ASC")) {
    criteria.addOrderByAscending(sortColumnName);
    } else {
    criteria.addOrderByDescending(sortColumnName);
    }
    // Se agrega el criteria por proyecto.
    criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
    // Ningun estado de finalizado, cobro o cotizacion
    // o sea que sean solo iniciado, iniciado y suspendido
    ArrayList listStatus = new ArrayList();
    listStatus.add(Integer.valueOf("2"));
    listStatus.add(Integer.valueOf("3"));
    listStatus.add(Integer.valueOf("4"));
    listStatus.add(Integer.valueOf("13"));
    criteria.addIn("status", listStatus);
    // Query of all the tasks
    Query query = new QueryByCriteria(tasksData.class, criteria);
    // ask the broker to retrieve the Extent collection
    Collection allLines = broker.getCollectionByQuery(query);
    // Se modifica el total de registros retornados para efectos
    // del paginado.
    setCount(new Integer(allLines.size()));
    if (page > 0) {
    // Se determinan los limites superior e inferior
    int inicio = (page - 1) * GAP_SIZE;
    int fin = page * GAP_SIZE;
    // now iterate over the result 
    return getCollection(allLines, inicio, fin);
    } else {
    return allLines.iterator();
    }
    }
     */
    /* Regresa una lista de todas las tareas asociadas con el miembro especificado 
     * que no sean finalizadas, en cobro o en cotizaciones.
     */
    public java.util.Iterator getListByMemberFiltered(String sortColumnName,
            String sortOrder, int idMember, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();


        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", new Integer(idAccount));
        // Ningun estado de finalizado, cobro o cotizacion
        // o sea que sean solo iniciado, iniciado y suspendido
        ArrayList listStatus = new ArrayList();
        listStatus.add(Integer.valueOf("2"));
        listStatus.add(Integer.valueOf("3"));
        listStatus.add(Integer.valueOf("4"));
        listStatus.add(Integer.valueOf("13"));

        criteria.addIn("status", listStatus);

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    public java.util.Iterator getAllListByMemberFiltered(String sortColumnName,
            String sortOrder, int idMember, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();


        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", new Integer(idAccount));
        // Ningun estado de finalizado, cobro o cotizacion
        // o sea que sean solo iniciado, iniciado y suspendido
        ArrayList listStatus = new ArrayList();
        listStatus.add(Integer.valueOf("2"));
        listStatus.add(Integer.valueOf("3"));
        listStatus.add(Integer.valueOf("12"));
        listStatus.add(Integer.valueOf("13"));
        listStatus.add(Integer.valueOf("14"));

        listStatus.add(Integer.valueOf("5"));
        listStatus.add(Integer.valueOf("6"));
        listStatus.add(Integer.valueOf("7"));
        listStatus.add(Integer.valueOf("8"));

        listStatus.add(Integer.valueOf("9"));
        listStatus.add(Integer.valueOf("10"));
        listStatus.add(Integer.valueOf("11"));

        listStatus.add(Integer.valueOf("0"));
        listStatus.add(Integer.valueOf("1"));
        listStatus.add(Integer.valueOf("4"));

        criteria.addIn("status", listStatus);

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    public java.util.Iterator getListByMemberFiltered(String sortColumnName,
            String sortOrder, int idMember, int page, int idAccount, int type) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();


        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", new Integer(idAccount));
        // Ningun estado de finalizado, cobro o cotizacion
        // o sea que sean solo iniciado, iniciado y suspendido
        ArrayList listStatus = new ArrayList();

        switch (type) {
            case 1:
                listStatus.add(Integer.valueOf("2"));
                listStatus.add(Integer.valueOf("3"));
                listStatus.add(Integer.valueOf("12"));
                listStatus.add(Integer.valueOf("13"));
                listStatus.add(Integer.valueOf("14"));
                listStatus.add(Integer.valueOf("9"));
                listStatus.add(Integer.valueOf("10"));
                listStatus.add(Integer.valueOf("11"));
                break;
            case 2:
                listStatus.add(Integer.valueOf("5"));
                listStatus.add(Integer.valueOf("6"));
                listStatus.add(Integer.valueOf("7"));
                listStatus.add(Integer.valueOf("8"));
                break;

            case 3:
                listStatus.add(Integer.valueOf("9"));
                listStatus.add(Integer.valueOf("10"));
                break;

            case 4:
                listStatus.add(Integer.valueOf("1"));
                listStatus.add(Integer.valueOf("4"));
                break;
            case 5:
                listStatus.add(Integer.valueOf("0"));
                break;
        }
        criteria.addIn("status", listStatus);


        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }
    /* Regresa una lista de todas las tareas asociadas con el miembro especificado 
     * que no sean finalizada por cliente, en cobro o en cotizaciones.
     */

    public java.util.Iterator getListByMemberFilteredForSchedule(String sortColumnName,
            String sortOrder, int idMember, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();


        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Ningun estado de finalizado, cobro o cotizacion
        // o sea que sean solo iniciado, iniciado y suspendido, finalizado y rechazado
        ArrayList listStatus = new ArrayList();
        listStatus.add(Integer.valueOf("1"));
        listStatus.add(Integer.valueOf("2"));
        listStatus.add(Integer.valueOf("3"));
        listStatus.add(Integer.valueOf("4"));
        listStatus.add(Integer.valueOf("12"));
        listStatus.add(Integer.valueOf("13"));

        criteria.addIn("status", listStatus);

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }
    
    public java.util.Iterator getListByMemberFilteredForSchedule(int idMember, int idAccount, boolean flag) throws PersistenceBrokerException {

        projectsData projectData = new projectsData();
        projectsBroker projectBroker = new projectsBroker();
        // New criteria for sortering
        Criteria criteria = new Criteria();

        criteria.addOrderByAscending("project");
        criteria.addOrderByAscending("name");

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Ningun estado de finalizado, cobro o cotizacion
        // o sea que sean solo iniciado, iniciado y suspendido y finalizado
        ArrayList listStatus = new ArrayList();
        listStatus.add(Integer.valueOf("2"));  // No Iniciada
        listStatus.add(Integer.valueOf("3"));  // Iniciada
        //listStatus.add(Integer.valueOf("4"));  // Suspendida
        listStatus.add(Integer.valueOf("12"));  // Rejected
        listStatus.add(Integer.valueOf("8"));  // QuoteAcepted
        listStatus.add(Integer.valueOf("13"));  // QA

        criteria.addIn("status", listStatus);

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Ahora se deben de filtrar todas aquellas tareas que estan finalizadas,
        // de forma tal que no se incluyan aquellas que no estan publicadas y poseen mas de
        // 10 de finalizadas
        Iterator e = allLines.iterator();
        tasksData tmp;
        ArrayList resultado = new ArrayList();
        while (e.hasNext()) {
            projectData = new projectsData();
            tmp = (tasksData) e.next();
            projectData = (projectsData) projectBroker.getData(tmp.getproject(), idAccount);
            if (tmp.getstatus() != 1 && tmp.getpublished().equalsIgnoreCase("0")) {
                if (projectData.getstatus() == 2 || projectData.getstatus() == 3) {
                    resultado.add(tmp);
                }
            }
        }

        return resultado.iterator();
    }


    /* Regresa una lista de todas las tareas asociadas con el miembro especificado 
     * que no sean finalizada por cliente, en cobro o en cotizaciones.
     */
    public java.util.Iterator getListByMemberFilteredForCalendar(String sortColumnName,
            String sortOrder, int idMember, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();


        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Ningun estado de finalizado, cobro o cotizacion
        // o sea que sean solo iniciado, iniciado y suspendido, y rechazado
        ArrayList listStatus = new ArrayList();
        listStatus.add(Integer.valueOf("2"));
        listStatus.add(Integer.valueOf("3"));
        listStatus.add(Integer.valueOf("4"));
        listStatus.add(Integer.valueOf("12"));
        listStatus.add(Integer.valueOf("13"));

        criteria.addIn("status", listStatus);

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa una lista de todas las tareas asociadas con el miembro especificado 
    para un proyecto dado*/
    public java.util.Iterator getListByMemberByProject(String sortColumnName,
            String sortOrder, int project, int idMember, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();


        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
        criteria.addEqualTo("project", Integer.valueOf("" + project));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa una lista de todas las tareas asociadas con el miembro especificado 
    para un proyecto dado*/
    public java.util.Iterator getListByMemberByProjectPublished(String sortColumnName,
            String sortOrder, int project, int idMember, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
        criteria.addEqualTo("project", Integer.valueOf("" + project));
        //criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa una lista de todas las tareas asociadas con el proyecto especificado 
     * que estan finalizadas y publicadas
     */
    public java.util.Iterator getListByProjectEnded(String sortColumnName,
            String sortOrder, int idProject, int page) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));

        // Solo tareas terminadas y publicadas
        criteria.addEqualTo("status", new Integer(1));
        criteria.addEqualTo("published", "1");

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa una lista de todas las tareas asociadas con el miembro especificado */
    /* Solo que devuelve todas ordenada por projecto y tarea */
    public java.util.Iterator getListByMember(int idMember, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        criteria.addOrderByAscending("project");
        criteria.addOrderByAscending("id");

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        return allLines.iterator();
    }
 /* Regresa una lista de todas los proyectos asociadas con member especificado */
    public java.util.Iterator getListByMemberFilteredForSchedules1(int user,int account) throws PersistenceBrokerException {
        Connection conn = null;
        ResultSet rs = null;
        Statement stmt1 = null;
        tasksData taskData= new tasksData();
        String query= "";        
        projectsData projectData= new projectsData();
        ArrayList tasks= new ArrayList();
        
            if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
        query = "SELECT tasks.id,tasks.project,tasks.priority,tasks.status,tasks.message,tasks.owner,tasks.assigned_to,tasks.name,tasks.description,tasks.start_date,tasks.due_date,"+
        "tasks.real_due_date,tasks.estimated_time,tasks.actual_time,tasks.completion,tasks.created,tasks.modified,tasks.assigned,tasks.published,"+
        "tasks.collect,tasks.send_quotation_date,tasks.reply_quotation_date,tasks.reply_quotation_member,tasks.tolerance,tasks.fare,tasks.predecessor"+
        ",tasks.predecessor_required,tasks.severity,tasks.type_task,tasks.spread_fix,tasks.comments,tasks.topic,tasks.id_account, projects.name as projName "+
        "FROM tasks, projects WHERE tasks.assigned_to= "+user+" and tasks.id_account= "+account +
        " AND tasks.status IN (2,3,12,8,13) AND tasks.project= projects.id AND projects.status IN (2,3) AND projects.id_account=tasks.id_account " +
        "UNION " +
        "SELECT tasks.id,tasks.project,tasks.priority,tasks.status,tasks.message,tasks.owner,tasks.assigned_to,tasks.name,tasks.description,tasks.start_date,tasks.due_date,"+
        "tasks.real_due_date,tasks.estimated_time,tasks.actual_time,tasks.completion,tasks.created,tasks.modified,tasks.assigned,tasks.published,"+
        "tasks.collect,tasks.send_quotation_date,tasks.reply_quotation_date,tasks.reply_quotation_member,tasks.tolerance,tasks.fare,tasks.predecessor"+
        ",tasks.predecessor_required,tasks.severity,tasks.type_task,tasks.spread_fix,tasks.comments,tasks.topic,tasks.id_account, projects.name as projName "+
        "FROM tasks, projects WHERE tasks.assigned_to= "+user+" and tasks.id_account="+account +
        "AND (tasks.status =1 AND tasks.published='0') AND tasks.project= projects.id " +
        "AND tasks.due_date >(current_date- integer '10') AND projects.status IN (2,3) AND projects.id_account=tasks.id_account order by 2,8";
            }else{
         query = "SELECT tasks.id,tasks.project,tasks.priority,tasks.status,tasks.message,tasks.owner,tasks.assigned_to,tasks.name,tasks.description,tasks.start_date,tasks.due_date,"+
        "tasks.real_due_date,tasks.estimated_time,tasks.actual_time,tasks.completion,tasks.created,tasks.modified,tasks.assigned,tasks.published,"+
        "tasks.collect,tasks.send_quotation_date,tasks.reply_quotation_date,tasks.reply_quotation_member,tasks.tolerance,tasks.fare,tasks.predecessor"+
        ",tasks.predecessor_required,tasks.severity,tasks.type_task,tasks.spread_fix,tasks.comments,tasks.topic,tasks.id_account, projects.name as projName "+
        "FROM tasks, projects WHERE tasks.assigned_to= "+user+" and tasks.id_account= "+account +
        " AND tasks.status IN (2,3,12,8,13) AND tasks.project= projects.id AND projects.status IN (2,3) AND projects.id_account=tasks.id_account " +
        "UNION " +
        "SELECT tasks.id,tasks.project,tasks.priority,tasks.status,tasks.message,tasks.owner,tasks.assigned_to,tasks.name,tasks.description,tasks.start_date,tasks.due_date,"+
        "tasks.real_due_date,tasks.estimated_time,tasks.actual_time,tasks.completion,tasks.created,tasks.modified,tasks.assigned,tasks.published,"+
        "tasks.collect,tasks.send_quotation_date,tasks.reply_quotation_date,tasks.reply_quotation_member,tasks.tolerance,tasks.fare,tasks.predecessor"+
        ",tasks.predecessor_required,tasks.severity,tasks.type_task,tasks.spread_fix,tasks.comments,tasks.topic,tasks.id_account, projects.name as projName "+
        "FROM tasks, projects WHERE tasks.assigned_to= "+user+" and tasks.id_account="+account +
        "AND (tasks.status =1 AND tasks.published='0') AND tasks.project= projects.id " +
        "AND tasks.due_date  > (SYSDATE-10) AND projects.status IN (2,3) AND projects.id_account=tasks.id_account order by 2,8";   
            }
//System.out.println("SQLLL= "+query);
        connectionClass _conecctionClass = new connectionClass();
        conn = _conecctionClass.getConnection();
        try {
            stmt1 = conn.createStatement();
            rs = stmt1.executeQuery(query);
             while (rs.next()) {
                            projectData= new projectsData();
                            taskData = new tasksData();
                            taskData.setid(rs.getInt("id"));
                            taskData.setproject(rs.getInt("project"));
                            taskData.setpriority(rs.getInt("priority"));
                            taskData.setstatus (rs.getInt("status"));
                            taskData.setmessage(rs.getInt("message"));
                            taskData.setowner(rs.getInt("owner"));
                            taskData.setassigned_to(rs.getInt("assigned_to"));
                            taskData.setname(rs.getString("name"));
                            taskData.setdescription(rs.getString("description"));
                            taskData.setstart_date(rs.getTimestamp("start_date"));
                            taskData.setdue_date(rs.getTimestamp("due_date"));
                            taskData.setreal_due_date(rs.getTimestamp("real_due_date"));
                            taskData.setestimated_time(rs.getBigDecimal("estimated_time"));
                            taskData.setactual_time(rs.getBigDecimal("actual_time"));
                            taskData.setcompletion(rs.getInt("completion"));
                            taskData.setcreated(rs.getTimestamp("created"));
                            taskData.setmodified(rs.getTimestamp("modified"));
                            taskData.setassigned(rs.getTimestamp("assigned"));
                            taskData.setpublished(rs.getString("published"));
                            taskData.setcollect(rs.getString("collect"));
                            taskData.setsend_quotation_date(rs.getTimestamp("send_quotation_date"));
                            taskData.setreply_quotation_date(rs.getTimestamp("reply_quotation_date"));
                            taskData.setreply_quotation_member(rs.getInt("reply_quotation_member"));
                            taskData.settolerance(rs.getInt("tolerance"));
                            taskData.setfare(rs.getBigDecimal("fare"));
                            taskData.setpredecessor(rs.getInt("predecessor"));
                            taskData.setpredecessor_required(rs.getString("predecessor_required"));
                            taskData.setseverity(rs.getString("severity"));
                            taskData.settype_task(rs.getInt("type_task"));
                            taskData.setspread_fix(rs.getString("spread_fix"));
                            taskData.setcomments(rs.getString("comments"));
                            taskData.settopic(rs.getInt("topic"));
                            taskData.setId_account(rs.getInt("id_account"));
                            projectData.setname(rs.getString("projName"));
                            taskData.setparentProject(projectData);
                            
                            tasks.add(taskData);
                            try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
                        }
        } catch (SQLException ex) {
            ex.printStackTrace();
        }
        try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
        return tasks.iterator();
    }
    
    /* Regresa una lista de todas las tareas asociadas con el miembro especificado */
    /* Solo que devuelve todas ordenada por projecto y tarea */
    public java.util.Iterator getListByMemberFilteredForSchedule(int idMember, int idAccount) throws PersistenceBrokerException {

        projectsData projectData = new projectsData();
        projectsBroker projectBroker = new projectsBroker();
        // New criteria for sortering
        Criteria criteria = new Criteria();

        criteria.addOrderByAscending("project");
        criteria.addOrderByAscending("name");

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Ningun estado de finalizado, cobro o cotizacion
        // o sea que sean solo iniciado, iniciado y suspendido y finalizado
        ArrayList listStatus = new ArrayList();
        listStatus.add(Integer.valueOf("1"));  // Finalizada
        listStatus.add(Integer.valueOf("2"));  // No Iniciada
        listStatus.add(Integer.valueOf("3"));  // Iniciada
        //listStatus.add(Integer.valueOf("4"));  // Suspendida
        listStatus.add(Integer.valueOf("12"));  // Rejected
        listStatus.add(Integer.valueOf("8"));  // QuoteAcepted
        listStatus.add(Integer.valueOf("13"));  // QA

        criteria.addIn("status", listStatus);
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Ahora se deben de filtrar todas aquellas tareas que estan finalizadas,
        // de forma tal que no se incluyan aquellas que no estan publicadas y poseen mas de
        // 10 de finalizadas
        Iterator e = allLines.iterator();
        tasksData tmp;
        ArrayList resultado = new ArrayList();
        Calendar hoy = Calendar.getInstance();
        hoy.set(Calendar.HOUR_OF_DAY, 1);
        Calendar terminoTarea = Calendar.getInstance();
        while (e.hasNext()) {
            projectData = new projectsData();
            tmp = (tasksData) e.next();
            projectData = (projectsData) projectBroker.getData(tmp.getproject(), idAccount);
            if (tmp.getstatus() == 1 && tmp.getpublished().equalsIgnoreCase("0")) {
                // es finalizada, hay que ver si aplica o no.
                terminoTarea.setTimeInMillis(tmp.getreal_due_date().getTime());
                terminoTarea.add(Calendar.DAY_OF_YEAR, EXPIRACION_TAREA);
                if (terminoTarea.before(hoy) == false) {
                    // Se agrega si y solo si, la fecha de terminacion no es menor a hoy por un
                    // margen de EXPIRACION_TAREA
                    if (projectData.getstatus() == 2 || projectData.getstatus() == 3) {
                        resultado.add(tmp);
                    }
                }
            } else {
                if (projectData.getstatus() == 2 || projectData.getstatus() == 3) {
                    resultado.add(tmp);
                }
            }
        }

        return resultado.iterator();
    }

    /* Regresa el reporte de performance de todas la tareas de este proyecto
     * y miembro particular */
    public java.util.Iterator getPerformanceReport(int project, int member,
            String type, Timestamp start, Timestamp end, String sortColumnName,
            String sortOrder, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();


        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto y miembro
        criteria.addEqualTo("project", Integer.valueOf("" + project));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Restringido en el espacio de fechas dadas.
        criteria.addGreaterOrEqualThan("due_date", start);
        criteria.addLessOrEqualThan("due_date", end);

        // Y deben estar en estado cerrado o en cualquiera de los
        // de cotizacion.
        ArrayList listStatus = new ArrayList();
        listStatus.add(Integer.valueOf("0")); //Finalizada Cliente
        listStatus.add(Integer.valueOf("1")); //Finalizada
        listStatus.add(Integer.valueOf("3")); //Iniciada
        listStatus.add(Integer.valueOf("4")); //Suspendida
        listStatus.add(Integer.valueOf("9")); //Cobro
        listStatus.add(Integer.valueOf("10")); // Cobro Enviado
        listStatus.add(Integer.valueOf("11")); //Procesando Cobro
        listStatus.add(Integer.valueOf("12")); //Rechazada
        listStatus.add(Integer.valueOf("13"));//QA
        listStatus.add(Integer.valueOf("14")); //StandBy
        criteria.addIn("status", listStatus);

        if (type.equalsIgnoreCase("byMember")) {
            criteria.addEqualTo("assigned_to", Integer.valueOf("" + member));
        }

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);


        // now iterate over the result 
        return allLines.iterator();
    }

    /* Regresa el reporte de performance de todas la tareas de este proyecto
     * y miembro particular, incluyendo las iniciadas */
    public java.util.ArrayList getCompletePerformanceReport(int project, int member,
            Timestamp start, Timestamp end, String sortColumnName,
            String sortOrder, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();


        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto y miembro
        criteria.addEqualTo("project", Integer.valueOf("" + project));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Restringido en el espacio de fechas dadas.
        //criteria.addGreaterOrEqualThan("due_date", start);
        //criteria.addLessOrEqualThan("due_date", end);

        // Y deben estar en estado iniciada, finalizada, 
        // cliente finalizado y suspendido, o rechazado
        ArrayList listStatus = new ArrayList();
        listStatus.add(Integer.valueOf("0")); //Finalizada Cliente
        listStatus.add(Integer.valueOf("1")); //Finalizada
        listStatus.add(Integer.valueOf("3")); //Iniciada
        listStatus.add(Integer.valueOf("4")); //Suspendida
        listStatus.add(Integer.valueOf("9")); //Cobro
        listStatus.add(Integer.valueOf("10")); // Cobro Enviado
        listStatus.add(Integer.valueOf("11")); //Procesando Cobro
        listStatus.add(Integer.valueOf("12")); //Rechazada
        listStatus.add(Integer.valueOf("13"));//QA
        listStatus.add(Integer.valueOf("14")); //StandBy
        criteria.addIn("status", listStatus);

//                assignmentsList
//                criteria.addEqualTo("assigned_to", Integer.valueOf("" + member));


        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // ArrayList de las tareas que se obtuvieron
        ArrayList listaTareas = new ArrayList();

        // Para cada tarea le vamos a calcular sus horas de calendarios y horarios.

        calendarBroker calBroker = new calendarBroker();

        // Procesamos cada tarea
        Iterator e = allLines.iterator();
        tasksData data;
        assignmentsData assignData;
        Iterator v;
        boolean tareaValida;
        while (e.hasNext()) {
            data = (tasksData) e.next();
            tareaValida = false;
            v = data.getassignmentsList().iterator();
            while (v.hasNext() && tareaValida == false) {
                assignData = (assignmentsData) v.next();

                if (assignData.getassigned_to() == member) {
                    tareaValida = true;
                }
            }

            if (tareaValida) {
                // Si esa tarea se debe considerar, ya que esta en lista de asignaciones
                // Total de horas segun los horarios.
                BigDecimal totHour = getTotalTaskRealHours(data.getid(), idAccount); //schBroker.getTotalTaskRealHours(data.getid(), idAccount);
                BigDecimal totMin = getTotalTaskRealMinutes(data.getid(), idAccount); //schBroker.getTotalTaskRealMinutes(data.getid(), idAccount);
                boolean band_min = false;
                String[] split_min = null;
                String replace_min = "";
                while (!band_min) {
                    if (totMin.compareTo(new BigDecimal("59")) == 1) {
                        totMin = totMin.divide(new BigDecimal(60), 2, BigDecimal.ROUND_UP);
                        replace_min = totMin.toString().replace('.', ',');
                        split_min = replace_min.split(",");
                        totHour = totHour.add(new BigDecimal(split_min[0]));
                        totMin = new BigDecimal("0." + split_min[1]);
                        totMin = totMin.multiply(new BigDecimal("60"));
                        if (totMin.toString().replace('.', ',').split(",").length > 1) {
                            replace_min = totMin.toString().replace('.', ',');
                            split_min = replace_min.split(",");
                            totMin = new BigDecimal(split_min[0]);
                        }
                    } else {
                        band_min = true;
                    }
                }

                if (totMin.toString().length() == 1) {
                    data.setTotalScheduledHours(new BigDecimal(totHour + ".0" + totMin));
                } else {
                    data.setTotalScheduledHours(new BigDecimal(totHour + "." + totMin));
                }
                // Total de horas segun los calendarios.
                data.setTotalCalendarHours(calBroker.getTotalTaskEstimatedTime(data.getid(), member,
                        start, end, idAccount));
                System.out.println("salio bien");
                if ((data.getstatus() == 1 || data.getstatus() == 0) &&
                        data.getTotalScheduledHours().longValue() == 0 &&
                        data.getTotalCalendarHours().longValue() == 0) {
                // Se trata de una tarea finalizada en cualquiera de las
                // dos modalidales en la cual no se ha trabajado nada, no se agrega
                } else {
                    // Se ve si esta atrasada o no.
                    if (data.getdue_date().before(end) &&
                            data.getstatus() == 3) {
                        data.setLate(true);
                    } else {
                        data.setLate(false);
                    }

                    // Se agrega a la lista de tareas
                    listaTareas.add(data);
                }
            }
        }

        calBroker.close();

        // now iterate over the result 
        return listaTareas;
    }

    public java.math.BigDecimal getTotalTaskRealHours(int taskid, int idAccount) throws PersistenceBrokerException {
        BigDecimal total = new BigDecimal("0");
        schedulesBroker schBroker = new schedulesBroker();
        total = schBroker.getTotalTaskRealHours(taskid, idAccount);
        schBroker.close();
        return total;
    }

    public java.math.BigDecimal getTotalTaskRealMinutes(int taskid, int idAccount) throws PersistenceBrokerException {
        BigDecimal total = new BigDecimal("0");
        schedulesBroker schBroker = new schedulesBroker();
        total = schBroker.getTotalTaskRealMinutes(taskid, idAccount);
        schBroker.close();
        return total;
    }
    /* Regresa el reporte de performance de todas la tareas de este proyecto
     * y miembro particular */

    public java.util.Iterator getPerformanceSummaryByMember(int project,
            Timestamp start, Timestamp end, int idAccount)
            throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto y miembro
        criteria.addEqualTo("project", Integer.valueOf("" + project));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Restringido en el espacio de fechas dadas.
        criteria.addGreaterOrEqualThan("due_date", start);
        criteria.addLessOrEqualThan("due_date", end);

        // Y deben estar en estado cerrado o en cualquiera de los
        // de cotizacion.
        ArrayList listStatus = new ArrayList();
        listStatus.add(Integer.valueOf("0"));
        listStatus.add(Integer.valueOf("1"));
        listStatus.add(Integer.valueOf("9"));
        listStatus.add(Integer.valueOf("10"));
        listStatus.add(Integer.valueOf("11"));
        criteria.addIn("status", listStatus);

        // Ordenado por el assigned_to y que no sea 0
        criteria.addNotEqualTo("assigned_to", "0");
        criteria.addOrderByAscending("assigned_to");

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);


        int memberActual = 0;

        // ask the broker to retrieve the Extent collection		
        Iterator e = broker.getCollectionByQuery(query).iterator();
        tasksData data;
        int contador = 0;
        java.math.BigDecimal deficit = new java.math.BigDecimal(0);
        ArrayList output = new ArrayList();

        while (e.hasNext()) {
            // Se toma la tarea.
            data = (tasksData) e.next();
            contador++;
            if (data.getassigned_to() != memberActual) {
                // Se da un cambio de miembro asignado, se debe guardar ese
                // valor de deficit mas reiniciar los contadores.
                if (memberActual != 0) {
                    Object[] salida = new Object[2];
                    salida[0] = new Integer(memberActual);

                    // Promedio del deficit
                    salida[1] = deficit.divide(
                            new java.math.BigDecimal(contador),
                            2, java.math.BigDecimal.ROUND_DOWN);

                    // Se agrega al arrayList
                    output.add(salida);
                }
                // Se resetean los valores.
                deficit = new java.math.BigDecimal(0);
                contador = 1;
                memberActual = data.getassigned_to();
            }
            // Se procede a sumar el deficit
            deficit = deficit.add(data.getdeficit());
        }

        // Nos quedo el ultimo tipo por fuera
        if (contador > 0) {
            // Se agrega a los resultados finales
            Object[] salida = new Object[2];
            salida[0] = new Integer(memberActual);

            // Promedio del deficit
            salida[1] = deficit.divide(
                    new java.math.BigDecimal(contador),
                    2, java.math.BigDecimal.ROUND_DOWN);

            // Se agrega al arrayList
            output.add(salida);
        }

        // now iterate over the result 
        return output.iterator();
    }

    private void setTotalRows(Criteria criteria) {
        // Se almacena el maximo de registros verdaderos, para ello
        // se procede con un count
        ReportQueryByCriteria q = QueryFactory.newReportQuery(
                tasksData.class, criteria);

        // define the 'columns' of the report
        q.setColumns(new String[]{"count(*)"});
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        Integer total = new Integer(0);

        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            total = (Integer) arr[0];

            // En caso de que sea nulo el resultado, se regresa 0
            if (total == null) {
                total = new Integer(0);
            }
        }

        // Se modifica la variable privada de total
        setCount(total);
    }

    /* Regresa una lista de todas las tareas asociadas con el proyecto especificado
    para el grupo de trabajo a fin de uso en el portal */
    public java.util.Iterator getListByProjectGroupForPortal(String sortColumnName,
            String sortOrder, int idProject, int page, int user, int idAccount, int type, String task) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // No nos interesan las tareas de los clientes
        criteria.addNotEqualTo("parentAssigned.profile", "2");
//                criteria.addNotEqualTo("assigned_to", Integer.valueOf("" + user));

        ArrayList cotizaciones = new ArrayList();
        cotizaciones.add(Integer.valueOf("6"));
        // Y no se despliegan cotizaciones.
        criteria.addNotIn("status", cotizaciones);

        if (type != 0) {
            ArrayList listStatus = new ArrayList();
            switch (type) {
                case 1:
                    listStatus.add(Integer.valueOf("2"));//Not Started
                    listStatus.add(Integer.valueOf("3"));//Started
                    listStatus.add(Integer.valueOf("12"));//Rejected
                    listStatus.add(Integer.valueOf("13"));//QA
                    break;
                case 2:
                    listStatus.add(Integer.valueOf("5"));//Quotation
                    listStatus.add(Integer.valueOf("7"));//Quote Rejected
                    listStatus.add(Integer.valueOf("8"));//Quote Acepted
                    break;
                case 3:
                    listStatus.add(Integer.valueOf("1"));
                    break;
                case 4:
                    listStatus.add(Integer.valueOf("0"));
                    break;
                case 5:
                    listStatus.add(Integer.valueOf("4"));
                    break;
                case 6:
                    listStatus.add(Integer.valueOf("14"));
                    break;

            }
            criteria.addIn("status", listStatus);
        }

        if (task != null && !task.equals("%") && !task.equals("")) {
            criteria.addLike("name", task.toUpperCase());
        }
        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));



        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa una lista de todas las tareas asociadas con el proyecto especificado
    para el usuario dado en el portal */
    public java.util.Iterator getListByProjectClientForPortal(String sortColumnName,
            String sortOrder, int idProject, int page, int user, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", new Integer(idProject));
        criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Y se muestran solo las tareas asignadas a una persona que sea miembro
        // de la empresa!! Profile = 2
        criteria.addEqualTo("parentAssigned.profile", "2");
//                criteria.addEqualTo("assigned_to", Integer.valueOf("" + user));

        ArrayList cotizaciones = new ArrayList();
        cotizaciones.add(Integer.valueOf("6"));

        // Y no se despliegan cotizaciones.
        criteria.addNotIn("status", cotizaciones);

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;



            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa una lista de todas las tareas cotizaciones asociadas con el proyecto especificado
    para el grupo de trabajo a fin de uso en el portal */
    public java.util.Iterator getListByProjectQuotesForPortal(String sortColumnName,
            String sortOrder, int idProject, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        ArrayList cotizaciones = new ArrayList();
        cotizaciones.add(Integer.valueOf("6"));

        // Y se despliegan solo las cotizaciones.
        criteria.addIn("status", cotizaciones);


        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));


        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa una lista de todas las tareas asociadas con el proyecto especificado
    y que estan publicadas. */
    public java.util.Iterator getListByProjectPublishedForPortal(String sortColumnName,
            String sortOrder, int idProject, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("project", Integer.valueOf("" + idProject));
        criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        ArrayList cotizaciones = new ArrayList();
        cotizaciones.add(Integer.valueOf("6"));

        // Y no se despliegan cotizaciones.
        criteria.addNotIn("status", cotizaciones);

        // Query of all the tasks
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));


        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /*
     * Metodo que transfiere todos las tareas del usuario dado al N/A
     */
    public void transferAllAssignedReferences(int memberId, int idAccount) throws PersistenceBrokerException {
        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("assigned_to", Integer.valueOf("" + memberId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the teams
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // Se actualiza cada entrada
        tasksData data;
        while (e.hasNext()) {
            data = (tasksData) e.next();
            tasksData dataNew = new tasksData(data);
            dataNew.setassigned_to(0); // Usuario NO ASIGNADO
            this.update(dataNew);
        }

    }

    /*
     * Metodo que transfiere todos las tareas con el duenno dado, al 
     * dueno del proyecto.
     */
    public void transferAllOwnerReferences(int memberId, int idAccount) throws PersistenceBrokerException {
        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("owner", Integer.valueOf("" + memberId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the teams
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // Se actualiza cada entrada
        tasksData data;
        while (e.hasNext()) {
            data = (tasksData) e.next();
            tasksData dataNew = new tasksData(data);
            // Se pone como owner al due?o del proyecto
            dataNew.setowner(data.getparentProject().getowner());
            this.update(dataNew);
        }
    }

    /*
     * Metodo que elimina todas las referencias de una tarea
     */
    public void deleteAllReferences(int memberId, int idAccount) throws PersistenceBrokerException {
        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por el due?o
        criteria.addEqualTo("owner", Integer.valueOf("" + memberId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the teams
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        schedulesBroker schBroker = new schedulesBroker();

        // Se borra cada entrada
        tasksData taskDel;
        while (e.hasNext()) {
            taskDel = (tasksData) e.next();

            // Se borran los schedules
            schBroker.deleteAllReferencesByTask(taskDel.getid(), idAccount);

            this.delete(taskDel);
        }
        schBroker.close();

        // Despu?s de borrar todas las tareas que son de proyectos donde el usuario es el
        // el due?o, se toman las tareas asignadas a l, de proyectos de otros usuarios, donde el no es el dueno, y se
        // reasignan estas a el dueno del proyecto. PATO

        Criteria criteria2 = new Criteria();
        criteria2.addEqualTo("assigned_to", Integer.valueOf("" + memberId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query de las tareas signadas al usuario donde el NO es el dueno del proyecto
        Query query2 = new QueryByCriteria(tasksData.class, criteria2);

        // ask the broker to retrieve the Extent collection
        Collection allLines2 = broker.getCollectionByQuery(query2);

        Iterator w = allLines2.iterator();

        // Se reasigna cada tarea al dueno del proyecto
        tasksData taskn;
        while (w.hasNext()) {
            taskn = (tasksData) w.next();
            taskn.setassigned_to(taskn.getowner());
            taskn.setname("REF. " + taskn.getparentAssigned().getlogin() + ": " + taskn.getname());
            this.update(taskn);
        }

    }

    /*
     * Metodo que elimina todas las referencias de una tarea
     */
    public void deleteAllReferencesbyAccount(int accountId) throws PersistenceBrokerException {
        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por el due?o
        criteria.addEqualTo("id_account", Integer.valueOf("" + accountId));

        // Query of all the teams
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        schedulesBroker schBroker = new schedulesBroker();

        // Se borra cada entrada
        tasksData taskDel;
        while (e.hasNext()) {
            taskDel = (tasksData) e.next();

            // Se borran los schedules
            schBroker.deleteAllReferencesByTask(taskDel.getid(), accountId);

            this.delete(taskDel);
        }
        schBroker.close();

        // Despu?s de borrar todas las tareas que son de proyectos donde el usuario es el
        // el due?o, se toman las tareas asignadas a l, de proyectos de otros usuarios, donde el no es el dueno, y se
        // reasignan estas a el dueno del proyecto. PATO

        Criteria criteria2 = new Criteria();
        criteria2.addEqualTo("id_account", Integer.valueOf("" + accountId));

        // Query de las tareas signadas al usuario donde el NO es el dueno del proyecto
        Query query2 = new QueryByCriteria(tasksData.class, criteria2);

        // ask the broker to retrieve the Extent collection
        Collection allLines2 = broker.getCollectionByQuery(query2);

        Iterator w = allLines2.iterator();

        // Se reasigna cada tarea al dueno del proyecto
        tasksData taskn;
        while (w.hasNext()) {
            taskn = (tasksData) w.next();
            taskn.setassigned_to(taskn.getowner());
            taskn.setname("REF. " + taskn.getparentAssigned().getlogin() + ": " + taskn.getname());
            this.update(taskn);
        }

    }

    /*
     * Metodo que elimina todas las referencias de las tareas de un proyecto
     */
    public void deleteAllReferencesByProject(int projectId, int idAccount) throws PersistenceBrokerException {
        assignmentsBroker assignBroker = new assignmentsBroker();
        schedulesBroker schBroker = new schedulesBroker();
        calendarBroker calBroker = new calendarBroker();
        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por el due?o
        criteria.addEqualTo("project", Integer.valueOf("" + projectId));
        // Se agrega el criteria por el due?o
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));


        // Query of all the teams
        Query query = new QueryByCriteria(tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();



        // Se borra cada entrada
        tasksData taskDel;
        while (e.hasNext()) {
            taskDel = (tasksData) e.next();
            assignBroker.deleteAssignments(taskDel.getowner(), taskDel.getid(), taskDel.getId_account());
            schBroker.deleteAllReferencesByTask(taskDel.getid(), taskDel.getId_account());
            calBroker.deleteAllReferencesbyTask(taskDel.getid(), taskDel.getId_account());
            // Se borran los schedules
            schBroker.deleteAllReferencesByTask(taskDel.getid(), idAccount);

            this.delete(taskDel);
        }
        assignBroker.close();
        schBroker.close();
    }

    /**
     * Metodo que regresa el total de elementos devueltos por un count(*)
     * generado por el metodo que saca las estadisticas de los proyectos,
     */
    private Integer getCount(Iterator iter) {
        Integer total = new Integer(0);
        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            if (arr[0].getClass().getName().equalsIgnoreCase("java.math.BigDecimal")) {
                //total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
                total = new Integer(arr[0].toString());
            } else {
                total = (Integer) arr[0];
            }

            // En caso de que sea nulo el resultado, se regresa 0
            if (total == null) {
                total = new Integer(0);
            }
        }
        return total;
    }

    /**
     * Metodo que regresa el siguiente consecutivo a ser empleado a nivel de los 
     * prefijos de tareas por tipo por proyecto.
     */
    public synchronized int getPrefixForTasks(int projectId, int typeTask, int idAccount) throws PersistenceBrokerException {

        // Query of all the schedules
        Criteria criteria = new Criteria();
        criteria.addEqualTo("project", new Integer(projectId));
        criteria.addEqualTo("type_task", new Integer(typeTask));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        ReportQueryByCriteria q = QueryFactory.newReportQuery(tasksData.class, criteria);

        // define the 'columns' of the report
        q.setColumns(new String[]{"count(*)"});
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        Integer total = new Integer(0);
        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            if (arr[0].getClass().getName().equalsIgnoreCase("java.math.BigDecimal")) {
                total = new Integer(arr[0].toString());
            } else {
                total = (Integer) new Integer(Integer.parseInt(arr[0].toString()));
            //     total = (Integer) arr[0];

            }

            // En caso de que sea nulo el resultado, se regresa 0
            if (total == null) {
                total = new Integer(0);
            }
        }

        // Se modifica la variable privada de total
        return total.intValue() + 1;

    }

     /**
     * Retorna la lista de tareas que pertenecen al usuario y al proyecto
     */
    public java.util.Iterator getTaskbySearch1(String project, String task, String code, int member, int idAccount) throws PersistenceBrokerException {
        Connection conn = null;
        ResultSet rs = null;
        Statement stmt1 = null;
        tasksData taskData= new tasksData();
        String query= "";        
        projectsData projectData= new projectsData();
        ArrayList tasks= new ArrayList();
        System.out.println("Entro a getTaskbySearch1");
        //int count = this.getProjectCount(member, idAccount);
        int count =1;
        if (count > 0) {
            
            query="SELECT tasks.id,tasks.project,tasks.priority,tasks.status,tasks.message,tasks.owner,tasks.assigned_to,tasks.name,tasks.description,tasks.start_date,tasks.due_date,"+
        "tasks.real_due_date,tasks.estimated_time,tasks.actual_time,tasks.completion,tasks.created,tasks.modified,tasks.assigned,tasks.published,"+
        "tasks.collect,tasks.send_quotation_date,tasks.reply_quotation_date,tasks.reply_quotation_member,tasks.tolerance,tasks.fare,tasks.predecessor"+
        ",tasks.predecessor_required,tasks.severity,tasks.type_task,tasks.spread_fix,tasks.comments,tasks.topic,tasks.id_account, projects.name as projName FROM tasks, projects WHERE ";
             if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
                if ("%".equals(project)) {
                    query+="like(cast(PROJECT as varchar),'" + project + "%') and tasks.status IN (2,3,8,12,13) and project in (select id from projects where status in (2,3))  AND like(tasks.NAME,'" + task + "%') and like(cast(tasks.ID as varchar),'" + code + "%') and tasks.assigned_to =" + member + " and tasks.id_account =" + idAccount;
                } else {
                    query+="like(cast(PROJECT as varchar),'" + project + "%') and tasks.status IN (2,3,8,12,13) AND like(tasks.NAME, '" + task + "%') and like(cast(tasks.ID as varchar),'" + code + "%') and tasks.assigned_to =" + member + " and tasks.id_account =" + idAccount;
                }
             } else {
                if ("%".equals(project)) {
                    query+="PROJECT LIKE '" + project + "' and project in (select id from projects where status in (2,3)) AND tasks.status IN (2,3,8,12,13)  AND tasks.NAME LIKE '" + task + "' and tasks.ID LIKE '" + code + "' and tasks.assigned_to =" + member + " and tasks.id_account =" + idAccount;
                } else {
                    query+="PROJECT LIKE " + project + "and tasks.status IN (2,3,8,12,13) AND tasks.NAME LIKE '" + task + "' and tasks.ID LIKE '" + code + "' and tasks.assigned_to =" + member + " and tasks.id_account =" + idAccount;
                }
            }
             query+=" AND tasks.project= projects.id AND tasks.id_account= projects.id_account ";
                   query+="UNION SELECT tasks.id,tasks.project,tasks.priority,tasks.status,tasks.message,tasks.owner,tasks.assigned_to,tasks.name,tasks.description,tasks.start_date,tasks.due_date,"+
        "tasks.real_due_date,tasks.estimated_time,tasks.actual_time,tasks.completion,tasks.created,tasks.modified,tasks.assigned,tasks.published,"+
        "tasks.collect,tasks.send_quotation_date,tasks.reply_quotation_date,tasks.reply_quotation_member,tasks.tolerance,tasks.fare,tasks.predecessor"+
        ",tasks.predecessor_required,tasks.severity,tasks.type_task,tasks.spread_fix,tasks.comments,tasks.topic,tasks.id_account, projects.name as projName FROM tasks, projects WHERE ";
        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
                if ("%".equals(project)) {
                    query+="like(cast(PROJECT as varchar),'" + project + "%') AND tasks.status=1 AND tasks.due_date >(current_date- integer '10') and tasks.project in (select id from projects where status in (2,3))  AND like(tasks.NAME,'" + task + "%') and like(cast(tasks.ID as varchar),'" + code + "%') and tasks.assigned_to =" + member + " and tasks.id_account =" + idAccount;
                } else {
                    query+="like(cast(PROJECT as varchar),'" + project + "%') AND tasks.status=1 AND tasks.due_date >(current_date- integer '10') AND like(tasks.NAME, '" + task + "%') and like(cast(tasks.ID as varchar),'" + code + "%') and tasks.assigned_to =" + member + " and tasks.id_account =" + idAccount;
                }
            } else {
                 query+="tasks.status=1 AND tasks.due_date  > (SYSDATE-10) AND ";
                if ("%".equals(project)) {
                    query+="PROJECT LIKE '" + project + "' and project in (select id from projects where status in (2,3))  AND tasks.NAME LIKE '" + task + "' and tasks.ID LIKE '" + code + "' and tasks.assigned_to =" + member + " and tasks.id_account =" + idAccount;
                } else {
                    query+="PROJECT LIKE " + project + " AND tasks.NAME LIKE '" + task + "' and tasks.ID LIKE '" + code + "' and tasks.assigned_to =" + member + " and tasks.id_account =" + idAccount;
                }
            }
        
             query+=" AND tasks.project= projects.id AND tasks.id_account= projects.id_account ";
        }
        System.out.println(" STATEMENT: "+query);
        connectionClass _conecctionClass = new connectionClass();
        conn = _conecctionClass.getConnection();
        try {
            stmt1 = conn.createStatement();
            rs = stmt1.executeQuery(query);
             while (rs.next()) {
                            projectData= new projectsData();
                            taskData = new tasksData();
                            taskData.setid(rs.getInt("id"));
                            taskData.setproject(rs.getInt("project"));
                            taskData.setpriority(rs.getInt("priority"));
                            taskData.setstatus (rs.getInt("status"));
                            taskData.setmessage(rs.getInt("message"));
                            taskData.setowner(rs.getInt("owner"));
                            taskData.setassigned_to(rs.getInt("assigned_to"));
                            taskData.setname(rs.getString("name"));
                            taskData.setdescription(rs.getString("description"));
                            taskData.setstart_date(rs.getTimestamp("start_date"));
                            taskData.setdue_date(rs.getTimestamp("due_date"));
                            taskData.setreal_due_date(rs.getTimestamp("real_due_date"));
                            taskData.setestimated_time(rs.getBigDecimal("estimated_time"));
                            taskData.setactual_time(rs.getBigDecimal("actual_time"));
                            taskData.setcompletion(rs.getInt("completion"));
                            taskData.setcreated(rs.getTimestamp("created"));
                            taskData.setmodified(rs.getTimestamp("modified"));
                            taskData.setassigned(rs.getTimestamp("assigned"));
                            taskData.setpublished(rs.getString("published"));
                            taskData.setcollect(rs.getString("collect"));
                            taskData.setsend_quotation_date(rs.getTimestamp("send_quotation_date"));
                            taskData.setreply_quotation_date(rs.getTimestamp("reply_quotation_date"));
                            taskData.setreply_quotation_member(rs.getInt("reply_quotation_member"));
                            taskData.settolerance(rs.getInt("tolerance"));
                            taskData.setfare(rs.getBigDecimal("fare"));
                            taskData.setpredecessor(rs.getInt("predecessor"));
                            taskData.setpredecessor_required(rs.getString("predecessor_required"));
                            taskData.setseverity(rs.getString("severity"));
                            taskData.settype_task(rs.getInt("type_task"));
                            taskData.setspread_fix(rs.getString("spread_fix"));
                            taskData.setcomments(rs.getString("comments"));
                            taskData.settopic(rs.getInt("topic"));
                            taskData.setId_account(rs.getInt("id_account"));
                            projectData.setname(rs.getString("projName"));
                            taskData.setparentProject(projectData);
                            
                            tasks.add(taskData);
                            try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
                        }
        } catch (SQLException ex) {
            ex.printStackTrace();
        }
        try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
        return tasks.iterator();
    }
     
        
    /**
     * Retorna la lista de tareas que pertenecen al usuario y al proyecto
     */
    public java.util.Iterator getTaskbySearch(String project, String task, String code, int member, int idAccount) throws PersistenceBrokerException {

        int count = this.getProjectCount(member, idAccount);
        ArrayList resultado = new ArrayList();
        if (count > 0) {
            // New criteria for sortering
            Criteria criteria = new Criteria();
            // We order the result set
            criteria.addOrderByAscending("project");
            criteria.addOrderByAscending("id");
            criteria.addOrderByAscending("name");
            // Se agrega el criteria por proyecto y miembro

            
            System.out.println(project);
            System.out.println(task);
            System.out.println(code);
            System.out.println(member);
            System.out.println(idAccount);
            if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
                if ("%".equals(project)) {
                    criteria.addSql("like(cast(PROJECT as varchar),'" + project + "%') and project in (select id from projects where status in (2,3))  AND like(NAME,'" + task + "%') and like(cast(ID as varchar),'" + code + "%') and assigned_to =" + member + " and id_account =" + idAccount);
                } else {
                    criteria.addSql("like(cast(PROJECT as varchar),'" + project + "%') AND like(NAME, '" + task + "%') and like(cast(ID as varchar),'" + code + "%') and assigned_to =" + member + " and id_account =" + idAccount);
                }
             } else {
                if ("%".equals(project)) {
                    criteria.addSql("PROJECT LIKE '" + project + "' and project in (select id from projects where status in (2,3))  AND NAME LIKE '" + task + "' and ID LIKE '" + code + "' and assigned_to =" + member + " and id_account =" + idAccount);
                } else {
                    criteria.addSql("PROJECT LIKE " + project + " AND NAME LIKE '" + task + "' and ID LIKE '" + code + "' and assigned_to =" + member + " and id_account =" + idAccount);
                }
            }
            
            ArrayList listStatus = new ArrayList();

            listStatus.add(Integer.valueOf(
                    "1"));  // Finalizada
            listStatus.add(Integer.valueOf("2"));  // No Iniciada
            listStatus.add(Integer.valueOf("3"));  // Iniciada
            listStatus.add(Integer.valueOf("12"));  // Rejected
            listStatus.add(Integer.valueOf("8"));  // QuoteAcepted
            listStatus.add(Integer.valueOf("13"));  // QA
            criteria.addIn(
                    "status", listStatus);


            // Query of all the tasks
            Query query = new QueryByCriteria(tasksData.class, criteria);

            // ask the broker to retrieve the Extent collection
            Collection allLines = broker.getCollectionByQuery(query);

            // Ahora se deben de filtrar todas aquellas tareas que estan finalizadas,
            // de forma tal que no se incluyan aquellas que no estan publicadas y poseen mas de
            // 10 de finalizadas
            Iterator e = allLines.iterator();
            tasksData tmp;

            Calendar hoy = Calendar.getInstance();
            hoy.set(Calendar.HOUR_OF_DAY,
                    1);
            Calendar terminoTarea = Calendar.getInstance();




            while (e.hasNext()) {
                tmp = (tasksData) e.next();
                if (tmp.getstatus() == 1 && tmp.getpublished().equalsIgnoreCase("0")) {
                    // es finalizada, hay que ver si aplica o no.
                    terminoTarea.setTimeInMillis(tmp.getreal_due_date().getTime());
                    terminoTarea.add(Calendar.DAY_OF_YEAR, EXPIRACION_TAREA);
                    if (terminoTarea.before(hoy) == false) {
                        // Se agrega si y solo si, la fecha de terminacion no es menor a hoy por un
                        // margen de EXPIRACION_TAREA
                        resultado.add(tmp);
                    }
                } else {
                    resultado.add(tmp);
                }
            }
        }
        return resultado.iterator();
    }

    /* Lista de proyectos por dueno */
    public int getProjectCount(int idMember, int accountId) {
        teamsData teamData = new teamsData();
        projectsBroker brokerProject = new projectsBroker();
        // New criteria for sortering
        Criteria criteria = new Criteria();
        // PASO #01.  Se extraen todos los proyectos en donde el miembro
        // indicado es el dueo.                
        // Se listan todo los proyectos si el usuario admin 24/03/04
        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("members", new Integer(idMember));
        criteria.addEqualTo("id_account", Integer.valueOf("" + accountId));

        // Query of all the tasks
        Query query =
                new QueryByCriteria(
                teamsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();
        projectsData projectData = new projectsData();
        ArrayList projects = new ArrayList();
        while (e.hasNext()) {
            projectData = new projectsData();
            teamData = (teamsData) e.next();
            // Los guardamos en un hash para que elimine de una vez los duplicados.
            projectData = (projectsData) brokerProject.getData(teamData.getprojects(), accountId);
            if (projectData.getstatus() == 2 || projectData.getstatus() == 3) {
                projects.add(projectData);
            }
        }
        return projects.size();
    }


    /* Regresa el total de horas estimadas de todas las tareas 
     * asociadas al proyecto indicado */
    public BigDecimal getSumEstimatedHours(
            int projectId, int idAccount) {

        BigDecimal total = new BigDecimal(0);
        Criteria crit = new Criteria();



        // Y donde sea el proyecto indicado.

        crit.addEqualTo("project", Integer.valueOf("" + projectId));

        crit.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        ReportQueryByCriteria q = QueryFactory.newReportQuery(
                tasksData.class, crit);
        // define the 'columns' of the report

        q.setColumns(
                new String[]{"sum(estimated_time)"});
        Iterator iter = broker.getReportQueryIteratorByQuery(q);



        // Se extrae la columna en cuestion
        while (iter.hasNext()) {

            Object[] arr = (Object[]) iter.next();



            total = (BigDecimal) arr[0];

        }
        // En caso de que sea nulo el resultado, se regresa 0
        if (total == null) {
            total = new BigDecimal(0);
        }
        return total;
    }

    /* Regresa el total de horas reales de todas las tareas 
     * asociadas al proyecto indicado */
    public BigDecimal getSumRealTime(
            int taskId, int idAccount) {

        BigDecimal total = new BigDecimal(0);



        Criteria crit = new Criteria();



        // Y donde sea el proyecto indicado.

        crit.addEqualTo("id", Integer.valueOf("" + taskId));
        crit.addEqualTo("id_account", Integer.valueOf("" + idAccount));


        ReportQueryByCriteria q = QueryFactory.newReportQuery(
                tasksData.class, crit);



        // define the 'columns' of the report

        q.setColumns(
                new String[]{"sum(actual_time)"});
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        // Se extrae la columna en cuestion
        while (iter.hasNext()) {

            Object[] arr = (Object[]) iter.next();

            total = (BigDecimal) arr[0];


        }
        // En caso de que sea nulo el resultado, se regresa 0
        if (total == null) {
            total = new BigDecimal(0);
        }
        return total;
    }
}
