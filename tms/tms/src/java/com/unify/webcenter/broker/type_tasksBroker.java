//   Generated by FlechaRoja Tech Tools (2003) 

package com.unify.webcenter.broker;

import com.unify.webcenter.data.*;

import org.apache.ojb.broker.query.*;
import org.apache.ojb.broker.*;
import java.util.*;

/**
* Class that represent the broker for the table tipos de tareas
* @author Administrator
*/
public class type_tasksBroker  extends MainBroker {

	public java.util.Iterator getList(int accountId) throws PersistenceBrokerException {
          // New criteria for sortering
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account",new Integer(accountId));
            // Query of all the task types
            Query query = new QueryByCriteria(type_tasksData.class, criteria);

            // ask the broker to retrieve the Extent collection
            Collection allLines = broker.getCollectionByQuery(query);

            // now iterate over the result to print each Service
            return allLines.iterator();
	}
        
     public java.util.Iterator getList(String sortColumnName, String sortOrder) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Query of all the assignments
        Query query = new QueryByCriteria(type_tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result 
        return allLines.iterator();
    }

	public java.util.Iterator getList(String sortColumnName, String sortOrder,int accountId) throws PersistenceBrokerException {
            // New criteria for sortering
            Criteria criteria = new Criteria();
            
            // We order the result set
            if (sortOrder.equalsIgnoreCase("ASC"))
                criteria.addOrderByAscending(sortColumnName);
            else
                criteria.addOrderByDescending(sortColumnName);
             criteria.addEqualTo("id_account",new Integer(accountId));
            // Query of all the task types
            Query query = new QueryByCriteria(type_tasksData.class, criteria);

            // ask the broker to retrieve the Extent collection
            Collection allLines = broker.getCollectionByQuery(query);

            // now iterate over the result to print each Service
            return allLines.iterator();
	}            


        /**
         * Metodo que regresa el prefijo a ser usado con la secuencia pertinente
         * para una tarea nueva, con base en el tipo de tarea q viene indicado
         */
        public synchronized String getPrefixForTasks(int idType, int idAccount) {            
            try {
                type_tasksData type = (type_tasksData) this.getData(idType, idAccount);
                
                // Se toma el valor actual, se le suma uno y se emplea
                // como el nuevo consecutivo y etiqueta de la tarea.
                int consecutivo = type.getconsecutive();
                consecutivo++;                
                type.setconsecutive(consecutivo);
                this.update(type);
                
                return type.getprefix() + "-" + consecutivo;
            } catch (Exception e) {
                System.out.println("type_tasksBroker: " + e.toString());
                return "";
            }
        }
        
        // Return the object associated with the key.
        public mainData getData(int id, int idAccount) {
            type_tasksData data = new type_tasksData();
            
            Criteria criteria = new Criteria();
            criteria.addEqualTo("id", new Integer(id)); 
            criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
            // Query of the exact task types
            Query query = new QueryByCriteria(type_tasksData.class, criteria);

            // ask the broker to retrieve the Extent collection
            Collection allLines = broker.getCollectionByQuery(query);

            Iterator e = allLines.iterator();            
            
            // If exists the record -MUST EXISTS ALWAYS
            if (e.hasNext()) 
                data = (type_tasksData) e.next();
            
            // We return the object
            return data;
        }
        
          // Return the object associated with the key.
        public mainData getData(int id) {
            type_tasksData data = new type_tasksData();
            
            Criteria criteria = new Criteria();
            criteria.addEqualTo("id", new Integer(id)); 
     
            // Query of the exact task types
            Query query = new QueryByCriteria(type_tasksData.class, criteria);

            // ask the broker to retrieve the Extent collection
            Collection allLines = broker.getCollectionByQuery(query);

            Iterator e = allLines.iterator();            
            
            // If exists the record -MUST EXISTS ALWAYS
            if (e.hasNext()) 
                data = (type_tasksData) e.next();
            
            // We return the object
            return data;
        }
        public java.util.Iterator getListByTask(String sortColumnName, String sortOrder, int page, int idAccount) throws PersistenceBrokerException {
            // New criteria for sortering
            Criteria criteria = new Criteria();
            
            // We order the result set
            if (sortOrder.equalsIgnoreCase("ASC"))
                criteria.addOrderByAscending(sortColumnName);
            else
                criteria.addOrderByDescending(sortColumnName);
            criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
            // Query of all the task types
            Query query = new QueryByCriteria(type_tasksData.class, criteria);

            Collection allLines = broker.getCollectionByQuery(query);
            
            setCount(new Integer(allLines.size())); 
            if (page > 0) {

                // Se determinan los limites superior e inferior
                int inicio = (page-1) * GAP_SIZE;
                int fin = page * GAP_SIZE;

                // now iterate over the result 
                return getCollection(allLines, inicio, fin);     

            } else {

                return allLines.iterator();

            }
       }

       public void deleteAllReferencesbyAccount(int id)  throws PersistenceBrokerException {

           // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("ID_ACCOUNT",new Integer(id));

        // Query of all the teams
        Query query = new QueryByCriteria(type_tasksData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // Se borran cada entrada y se reapunta al duenno del proyecto.
        while (e.hasNext()) {
            this.delete(e.next());
        }


    }

 }