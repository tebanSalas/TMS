//   Generated by FlechaRoja Tech Tools (2003) 
package com.unify.webcenter.broker;

import com.unify.webcenter.data.mainData;
import com.unify.webcenter.data.projectsData;
import com.unify.webcenter.data.tasksData;

import com.unify.webcenter.data.teamsData;
import com.unify.webcenter.tools.connectionClass;
import java.math.BigDecimal;
import java.util.Collection;
import java.util.Iterator;
import org.apache.commons.beanutils.*;
import org.apache.ojb.broker.*;
import org.apache.ojb.broker.query.*;
import java.util.*;
import java.util.ArrayList;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
/**
 * Class that represent the broker for the table projects
 * @author Administrator
 */
public class projectsBroker extends MainBroker {

    public Iterator getList(int accountId) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", new Integer(accountId));

        // Query of all the projects

        Query query = new QueryByCriteria(projectsData.class, criteria);



        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        //broker.close();
        // now iterate over the result to print each Service

        return allLines.iterator();

    }

    public java.util.Iterator getList(String sortColumnName, String sortOrder) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        // Query of all the assignments
        Query query = new QueryByCriteria(projectsData.class, criteria);
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        // now iterate over the result
       // broker.close();
        return allLines.iterator();
    }

    public Iterator getList(String sortColumnName, String sortOrder, int accountId) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();



        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        criteria.addEqualTo("id_account", new Integer(accountId));


        // Query of all the projects

        Query query = new QueryByCriteria(projectsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);


        //broker.close();

        // now iterate over the result 

        return allLines.iterator();

    }

    public Iterator getListSubProj(int idProject, int type, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering

        Criteria criteria = new Criteria();

        // We order the result set

        criteria.addEqualTo("project_id", new Integer(idProject));
        criteria.addEqualTo("id_account", new Integer(idAccount));
        // Se filtran de acuerdo al tipo q poseen

        ArrayList listStatus = new ArrayList();
        switch (type) {
            case 1:
                listStatus.add(Integer.valueOf("4"));
                listStatus.add(Integer.valueOf("1"));
                break;
            case 2:
                listStatus.add(Integer.valueOf("2"));
                listStatus.add(Integer.valueOf("3"));
                listStatus.add(Integer.valueOf("5"));
                break;
        }
        criteria.addIn("status", listStatus);

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);
        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        //broker.close();
        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));
        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {

            // now iterate over the result 

            return allLines.iterator();
        }

    }

    public Iterator getListSubProj(int idProject, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering

        Criteria criteria = new Criteria();

        // We order the result set

        criteria.addEqualTo("project_id", new Integer(idProject));
        criteria.addEqualTo("id_account", new Integer(idAccount));
        // Se filtran de acuerdo al tipo q poseen

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);
        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        //broker.close();
        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));
        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {

            // now iterate over the result 

            return allLines.iterator();
        }

    }

    public Iterator getListSubProjPortal(int idProject, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();

        criteria.addEqualTo("project_id", new Integer(idProject));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        criteria.addEqualTo("published","1");
        
        // Query of all the projects

        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        //broker.close();
        // now iterate over the result 

        return allLines.iterator();

    }

    public Iterator getListProyDelete(int idProject, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering
        Criteria criteria = new Criteria();

        // criteria.addEqualTo("sec_projects", new Integer(idProject));
        // Query of all the projects

        criteria.addSql("sec_projects LIKE '%" + idProject + "%' and id_account=" + idAccount);
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

      // broker.close();
        // now iterate over the result 

        return allLines.iterator();

    }

    public projectsData getDataSubProj(int idProject, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering
        projectsData data = new projectsData();
        Criteria criteria = new Criteria();

        criteria.addEqualTo("project_id", new Integer(idProject));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the projects

        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);
        Iterator e = allLines.iterator();

        // If exists the record -MUST EXISTS ALWAYS

        if (e.hasNext()) {
            data = (projectsData) e.next();
        }



        //broker.close();
        // now iterate over the result 

        return data;

    }

    // Return the object associated with the key.
    public mainData getData(int id, int idAccount) {

        projectsData data = new projectsData();

        Criteria criteria = new Criteria();

        criteria.addEqualTo("id", new Integer(id));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));


        // Query of the exact organization

        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        //broker.close();
        Iterator e = allLines.iterator();

        // If exists the record -MUST EXISTS ALWAYS

        if (e.hasNext()) {
            data = (projectsData) e.next();
        }



        // We return the object

        return data;

    }

    public com.unify.webcenter.data.mainData getData(int id) {
        projectsData data = new projectsData();
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id", new Integer(id));

        // Query of the exact organization
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        Iterator e = allLines.iterator();
        // If exists the record -MUST EXISTS ALWAYS

        if (e.hasNext()) {
            data = (projectsData) e.next();
        }

        //broker.close();
        // We return the object
        return data;
    }

    private boolean isAdmin(String profile) {
        boolean isit = false;
        if (profile.equals("3") || profile.equals("4")) // 1 es el
        {
            isit = true;
        }
        return isit;
    }

    /* Regresa la lista de todos los proyectos en los cuales el miembro indicado
     * forma parte del equipo */
    public Iterator getListByMember(String sortColumnName, String sortOrder, int idMember,
            int page, String profile, int accountId) throws PersistenceBrokerException {

        // New criteria for sortering
        Criteria criteria = new Criteria();

        // PASO #01.  Se extraen todos los proyectos en donde el miembro
        // indicado es el dueño.                
        // Se listan todo los proyectos si el usuario admin 24/03/04
        if (isAdmin(profile) == false) {
            criteria.addEqualTo("owner", Integer.valueOf("" + idMember));
        }
        criteria.addEqualTo("id_account", new Integer(accountId));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // PASO #02.  Se extraen todos los proyectos en donde el miembro
        // indicado no es el dueño, pero pertenece a este proyecto por medio
        // del equipo.  
        // Modificacion Jury:  Este paso se da solo si no es el admin que ya tiene
        // la condicion de listar todos los proyectos activos

        if (isAdmin(profile) == false) {
            criteria = new Criteria();
            criteria.addNotEqualTo("owner", Integer.valueOf("" + idMember));
            criteria.addEqualTo("detailTeams.parentMember.id", Integer.valueOf("" + idMember));
            criteria.addEqualTo("id_account", Integer.valueOf("" + accountId));
            criteria.addEqualTo("project_id", Integer.valueOf("0"));
            // We order the result set
            if (sortOrder.equalsIgnoreCase("ASC")) {
                criteria.addOrderByAscending(sortColumnName);
            } else {
                criteria.addOrderByDescending(sortColumnName);
            }
            // Query of all the projects
            query = new QueryByCriteria(projectsData.class, criteria);

            // ask the broker to retrieve the Extent collection
            Collection allLines2 = broker.getCollectionByQuery(query);

            // PASO # 03. Se debe hacer un merge entre los dos Collections
            // allLines y allLines2 
            allLines.addAll(allLines2);
        }

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));
        //broker.close();
        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;
            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    public Iterator getListByMemberProject(String sortColumnName, String sortOrder, int idMember,
            int page, String profile, int accountId) throws PersistenceBrokerException {

        // New criteria for sortering
        Criteria criteria = new Criteria();

        // PASO #01.  Se extraen todos los proyectos en donde el miembro
        // indicado es el dueño.                
        // Se listan todo los proyectos si el usuario admin 24/03/04
        if (isAdmin(profile) == false) {
            criteria.addEqualTo("owner", Integer.valueOf("" + idMember));
        }
        criteria.addEqualTo("id_account", new Integer(accountId));
        criteria.addEqualTo("project_id", Integer.valueOf("0"));
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // PASO #02.  Se extraen todos los proyectos en donde el miembro
        // indicado no es el dueño, pero pertenece a este proyecto por medio
        // del equipo.  
        // Modificacion Jury:  Este paso se da solo si no es el admin que ya tiene
        // la condicion de listar todos los proyectos activos

        if (isAdmin(profile) == false) {
            criteria = new Criteria();
            criteria.addNotEqualTo("owner", Integer.valueOf("" + idMember));
            criteria.addEqualTo("detailTeams.parentMember.id", Integer.valueOf("" + idMember));
            criteria.addEqualTo("id_account", Integer.valueOf("" + accountId));
            criteria.addEqualTo("project_id", Integer.valueOf("0"));
            // We order the result set
            if (sortOrder.equalsIgnoreCase("ASC")) {
                criteria.addOrderByAscending(sortColumnName);
            } else {
                criteria.addOrderByDescending(sortColumnName);
            }
            // Query of all the projects
            query = new QueryByCriteria(projectsData.class, criteria);

            // ask the broker to retrieve the Extent collection
            Collection allLines2 = broker.getCollectionByQuery(query);

            // PASO # 03. Se debe hacer un merge entre los dos Collections
            // allLines y allLines2 
            allLines.addAll(allLines2);
        }

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));
        //broker.close();
        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;
            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    public Iterator getListByMember(String sortColumnName, String sortOrder, int idMember,
            int page, String profile, int accountId, int type) throws PersistenceBrokerException {

        // New criteria for sortering
        Criteria criteria = new Criteria();

        // PASO #01.  Se extraen todos los proyectos en donde el miembro
        // indicado es el dueño.                
        // Se listan todo los proyectos si el usuario admin 24/03/04
        if (isAdmin(profile) == false) {
            criteria.addEqualTo("owner", Integer.valueOf("" + idMember));
        }
        criteria.addEqualTo("id_account", new Integer(accountId));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se filtran de acuerdo al tipo q poseen
        ArrayList listStatus = new ArrayList();
        switch (type) {
            case 1:
                listStatus.add(Integer.valueOf("4"));
                listStatus.add(Integer.valueOf("1"));
                break;
            case 2:
                listStatus.add(Integer.valueOf("2"));
                listStatus.add(Integer.valueOf("3"));
                listStatus.add(Integer.valueOf("5"));
                break;
        }
        criteria.addIn("status", listStatus);

        criteria.addEqualTo("project_id", Integer.valueOf("0"));

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // PASO #02.  Se extraen todos los proyectos en donde el miembro
        // indicado no es el dueño, pero pertenece a este proyecto por medio
        // del equipo.  
        // Modificacion Jury:  Este paso se da solo si no es el admin que ya tiene
        // la condicion de listar todos los proyectos activos

        if (isAdmin(profile) == false) {
            criteria = new Criteria();
            criteria.addNotEqualTo("owner", Integer.valueOf("" + idMember));
            criteria.addEqualTo("detailTeams.parentMember.id", Integer.valueOf("" + idMember));
            criteria.addEqualTo("id_account", Integer.valueOf("" + accountId));
            criteria.addEqualTo("project_id", Integer.valueOf("0"));
            // We order the result set
            if (sortOrder.equalsIgnoreCase("ASC")) {
                criteria.addOrderByAscending(sortColumnName);
            } else {
                criteria.addOrderByDescending(sortColumnName);
            }
            // Se filtran de acuerdo al tipo q poseen

            criteria.addIn("status", listStatus);

            // Query of all the projects
            query = new QueryByCriteria(projectsData.class, criteria);

            // ask the broker to retrieve the Extent collection
            Collection allLines2 = broker.getCollectionByQuery(query);

            // PASO # 03. Se debe hacer un merge entre los dos Collections
            // allLines y allLines2 
            allLines.addAll(allLines2);
        }
        //broker.close();
        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;
            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /* Regresa la lista de todos los proyectos en los cuales el miembro indicado
     * forma parte del equipo */
    /*    public Iterator getListByMember(String sortColumnName, String sortOrder, int idMember,
    int page, int type, String profile, int accountId) throws PersistenceBrokerException {
    // New criteria for sortering
    Criteria criteria = new Criteria();
    // PASO #01.  Se extraen todos los proyectos en donde el miembro
    // indicado es el dueÃ±o.                
    // Se listan todo los proyectos si el usuario admin 24/03/04
    if (isAdmin(profile) == false) {
    criteria.addEqualTo("owner", Integer.valueOf("" + idMember));
    }
    criteria.addEqualTo("project_id", Integer.valueOf("0"));
    criteria.addEqualTo("id_account", new Integer(accountId));
    // Filtramos por el tipo
    // Se filtran de acuerdo al tipo q poseen
    ArrayList listStatus = new ArrayList();
    switch (type) {
    case 1:
    listStatus.add(Integer.valueOf("4"));
    listStatus.add(Integer.valueOf("1"));
    break;
    case 2:
    listStatus.add(Integer.valueOf("2"));
    listStatus.add(Integer.valueOf("3"));
    listStatus.add(Integer.valueOf("5"));
    break;
    }
    criteria.addIn("status", listStatus);
    // We order the result set
    if (sortOrder.equalsIgnoreCase("ASC")) {
    criteria.addOrderByAscending(sortColumnName);
    } else {
    criteria.addOrderByDescending(sortColumnName);
    }
    // Query of all the projects
    Query query = new QueryByCriteria(projectsData.class, criteria);
    // ask the broker to retrieve the Extent collection
    Collection allLines = broker.getCollectionByQuery(query);
    // PASO #02.  Se extraen todos los proyectos en donde el miembro
    // indicado no es el dueño, pero pertenece a este proyecto por medio
    // del equipo.  
    // Modificacion Jury:  Este paso se da solo si no es el admin que ya tiene
    // la condicion de listar todos los proyectos activos
    if (isAdmin(profile) == false) {
    criteria = new Criteria();
    criteria.addNotEqualTo("owner", Integer.valueOf("" + idMember));
    criteria.addEqualTo("project_id", Integer.valueOf("0"));
    criteria.addEqualTo("detailTeams.parentMember.id", Integer.valueOf("" + idMember));
    // We order the result set
    if (sortOrder.equalsIgnoreCase("ASC")) {
    criteria.addOrderByAscending(sortColumnName);
    } else {
    criteria.addOrderByDescending(sortColumnName);
    }
    // Filtramos por el tipo
    if (type == 1) {
    criteria.addEqualTo("status", Integer.valueOf("1"));
    } else {
    criteria.addNotEqualTo("status", Integer.valueOf("1"));
    }
    // Query of all the projects
    query = new QueryByCriteria(projectsData.class, criteria);
    // ask the broker to retrieve the Extent collection
    Collection allLines2 = broker.getCollectionByQuery(query);
    // PASO # 03. Se debe hacer un merge entre los dos Collections
    // allLines y allLines2 
    allLines.addAll(allLines2);
    }
    // Se modifica el total de registros retornados para efectos
    // del paginado.
    setCount(new Integer(allLines.size()));
    if (page > 0) {
    // Se determinan los limites superior e inferior
    int inicio = (page - 1) * GAP_SIZE;
    int fin = page * GAP_SIZE;
    // now iterate over the result 
    return getCollection(allLines, inicio, fin);
    } else {
    return allLines.iterator();
    }
    }*/
    /* Lista de proyectos por dueno */
    public Iterator getListByOwner(String sortColumnName, String sortOrder, int idMember, int page, int accountId) throws PersistenceBrokerException {

        // New criteria for sortering
        Criteria criteria = new Criteria();

        // PASO #01.  Se extraen todos los proyectos en donde el miembro
        // indicado es el dueño.                
        // Se listan todo los proyectos si el usuario admin 24/03/04
        criteria.addEqualTo("owner", Integer.valueOf("" + idMember));

        criteria.addEqualTo("id_account", new Integer(accountId));
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        //broker.close();
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);

        } else {
            return allLines.iterator();
        }
    }

    public Iterator getListProy(String sortColumnName, String sortOrder, int page, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering
        Criteria criteria = new Criteria();

        // PASO #01.  Se extraen todos los proyectos en donde el miembro
        // indicado es el dueño.                
        // Se listan todo los proyectos si el usuario admin 24/03/04
        criteria.addEqualTo("project_id", Integer.valueOf("" + 0));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        //broker.close();
        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);

        } else {
            return allLines.iterator();
        }
    }

    public Iterator getListPrincProy(String sortColumnName, String sortOrder, int page, int proj, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering
        Criteria criteria = new Criteria();

        // PASO #01.  Se extraen todos los proyectos en donde el miembro
        // indicado es el dueño.                
        // Se listan todo los proyectos si el usuario admin 24/03/04
        criteria.addEqualTo("project_id", Integer.valueOf("" + 0));
        criteria.addNotEqualTo("id", Integer.valueOf("" + proj));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));
        //broker.close();

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);

        } else {
            return allLines.iterator();
        }
    }

    /* Lista de proyectos por dueno */
    /*   public int getProjectCountByOwner(int idMember) {
    // New criteria for sortering
    Criteria criteria = new Criteria();
    // PASO #01.  Se extraen todos los proyectos en donde el miembro
    // indicado es el dueño.                
    // Se listan todo los proyectos si el usuario admin 24/03/04
    criteria.addEqualTo("owner", Integer.valueOf("" + idMember));
    // Query of all the projects
    Query query = new QueryByCriteria(projectsData.class, criteria);
    Collection allLines = broker.getCollectionByQuery(query);
    return allLines.size();
    }
     */
    /* Lista de proyectos por dueno */
    public int getProjectCountByOwner(int idMember, int accountId) {

        // New criteria for sortering
        Criteria criteria = new Criteria();

        // PASO #01.  Se extraen todos los proyectos en donde el miembro
        // indicado es el dueÃ±o.                
        // Se listan todo los proyectos si el usuario admin 24/03/04
        criteria.addEqualTo("owner", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_Account", new Integer(accountId));

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);
        Collection allLines = broker.getCollectionByQuery(query);

        //broker.close();
        return allLines.size();
    }

    /* Regresa la lista de todos los proyectos en los cuales el miembro indicado
     * forma parte del equipo y ademas, el proyecto esta publicado*/
    public Iterator getListByMemberForPortal(String sortColumnName, String sortOrder, int idMember, int page, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();





        // PASO #01.  Se extraen todos los proyectos en donde el miembro

        // indicado es el dueño y esta publicado

        criteria.addEqualTo("owner", Integer.valueOf("" + idMember));

        criteria.addEqualTo("published", "1");

        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }



        // Query of all the projects

        Query query = new QueryByCriteria(projectsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);





        // PASO #02.  Se extraen todos los proyectos en donde el miembro

        // indicado no es el dueño, pero pertenece a este proyecto por medio

        // del equipo

        criteria = new Criteria();

        criteria.addNotEqualTo("owner", Integer.valueOf("" + idMember));

        criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        criteria.addEqualTo("detailTeams.parentMember.id",
                Integer.valueOf("" + idMember));





        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }



        // Query of all the projects

        query = new QueryByCriteria(projectsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines2 = broker.getCollectionByQuery(query);


        //broker.close();

        // PASO # 03. Se debe hacer un merge entre los dos Collections

        // allLines y allLines2

        allLines.addAll(allLines2);



        // Se modifica el total de registros retornados para efectos

        // del paginado.

        setCount(new Integer(allLines.size()));



        if (page > 0) {

            // Se determinan los limites superior e inferior

            int inicio = (page - 1) * GAP_SIZE;

            int fin = page * GAP_SIZE;



            // now iterate over the result 

            return getCollection(allLines, inicio, fin);

        } else {

            return allLines.iterator();

        }

    }

    /* Regresa la lista de todos los proyectos en los cuales la organizacion
     * indicada es la que esta asignada */
    public Iterator getListByOrganization(String sortColumnName, String sortOrder, int idOrg, int page, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();



        // Y donde sea el dueño

        criteria.addEqualTo("organization", Integer.valueOf("" + idOrg));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        criteria.addEqualTo("project_id", Integer.valueOf("0"));
        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }



        // Query of all the projects

        Query query = new QueryByCriteria(projectsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        // Se modifica el total de registros retornados para efectos

        // del paginado.

        setCount(new Integer(allLines.size()));

        //broker.close();


        if (page > 0) {

            // Se determinan los limites superior e inferior

            int inicio = (page - 1) * GAP_SIZE;

            int fin = page * GAP_SIZE;



            // now iterate over the result 

            return getCollection(allLines, inicio, fin);

        } else {

            // Se retornan todos los registros

            return allLines.iterator();

        }

    }

    /* Regresa la lista de todos los proyectos en los cuales la organizacion
     * indicada es la que esta asignada */
    public Iterator getListByOrganization(String sortColumnName, String sortOrder, int idOrg, int page, int idAccount, int type) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();



        // Y donde sea el dueño

        criteria.addEqualTo("organization", Integer.valueOf("" + idOrg));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        criteria.addEqualTo("project_id", Integer.valueOf("0"));
        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Se filtran de acuerdo al tipo q poseen
        ArrayList listStatus = new ArrayList();
        switch (type) {
            case 1:
                listStatus.add(Integer.valueOf("4"));
                listStatus.add(Integer.valueOf("1"));
                break;
            case 2:
                listStatus.add(Integer.valueOf("2"));
                listStatus.add(Integer.valueOf("3"));
                listStatus.add(Integer.valueOf("5"));
                break;
        }
        criteria.addIn("status", listStatus);

        // Query of all the projects

        Query query = new QueryByCriteria(projectsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        // Se modifica el total de registros retornados para efectos

        // del paginado.

        setCount(new Integer(allLines.size()));


        //broker.close();

        if (page > 0) {

            // Se determinan los limites superior e inferior

            int inicio = (page - 1) * GAP_SIZE;

            int fin = page * GAP_SIZE;



            // now iterate over the result 

            return getCollection(allLines, inicio, fin);

        } else {

            // Se retornan todos los registros

            return allLines.iterator();

        }

    }

    /* Regresa la lista de todos los proyectos en los cuales la organizacion
     * indicada es la que esta asignada y estan publicados */
    public Iterator getListByOrganizationForPortal(String sortColumnName, String sortOrder, int idOrg, int page, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();

        // Y donde sea el dueño

        criteria.addEqualTo("organization", Integer.valueOf("" + idOrg));

        criteria.addEqualTo("published", "1");

        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        
        criteria.addEqualTo("project_id", "0");

        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }



        // Query of all the projects

        Query query = new QueryByCriteria(projectsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        // Se modifica el total de registros retornados para efectos

        // del paginado.

        setCount(new Integer(allLines.size()));

        //broker.close();


        if (page > 0) {

            // Se determinan los limites superior e inferior

            int inicio = (page - 1) * GAP_SIZE;

            int fin = page * GAP_SIZE;



            // now iterate over the result 

            return getCollection(allLines, inicio, fin);

        } else {

            // Se retornan todos los registros

            return allLines.iterator();

        }

    }

    /* Regresa el total de horas estimadas de todas las tareas 
     * asociadas al proyecto indicado */
    public BigDecimal getSumEstimatedHours(int projectId, int idAccount) {

        BigDecimal total = new BigDecimal(0);



        Criteria crit = new Criteria();



        // Y donde sea el proyecto indicado.

        crit.addEqualTo("project", Integer.valueOf("" + projectId));

        crit.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        ReportQueryByCriteria q = QueryFactory.newReportQuery(
                tasksData.class, crit);



        // define the 'columns' of the report

        q.setColumns(new String[]{"sum(estimated_time)"});



        Iterator iter = broker.getReportQueryIteratorByQuery(q);



        // Se extrae la columna en cuestion

        while (iter.hasNext()) {

            Object[] arr = (Object[]) iter.next();



            total = (BigDecimal) arr[0];

        }



        // En caso de que sea nulo el resultado, se regresa 0

        if (total == null) {
            total = new BigDecimal(0);
        }

        //broker.close();

        return total;

    }

    /* Regresa el total de horas reales de todas las tareas 
     * asociadas al proyecto indicado */
    public BigDecimal getSumActualHours(int projectId, int idAccount) {

        BigDecimal total = new BigDecimal(0);



        Criteria crit = new Criteria();



        // Y donde sea el proyecto indicado.

        crit.addEqualTo("project", Integer.valueOf("" + projectId));

        crit.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        ReportQueryByCriteria q = QueryFactory.newReportQuery(
                tasksData.class, crit);



        // define the 'columns' of the report

        q.setColumns(new String[]{"sum(actual_time)"});



        Iterator iter = broker.getReportQueryIteratorByQuery(q);



        // Se extrae la columna en cuestion

        while (iter.hasNext()) {

            Object[] arr = (Object[]) iter.next();

            total = (BigDecimal) arr[0];


        }



        // En caso de que sea nulo el resultado, se regresa 0

        if (total == null) {
            total = new BigDecimal(0);
        }
        //broker.close();

        return total;

    }

    // Regresa la lista de los proyectos en estado activo, o sea estado = 3 */
    public Iterator getActiveProjects(String sortColumnName, String sortOrder) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();



        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }



        // Solo los proyectos activos.

        criteria.addEqualTo("status", "3");


        // Query of all the projects

        Query query = new QueryByCriteria(projectsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        //broker.close();

        // now iterate over the result 

        return allLines.iterator();

    }

    /*
     * Metodo que transfiere todos los proyectos del usuario dado al administrador
     */
    public void transferAllReferences(int memberId, int idAccount) throws Exception {

        // New criteria for search

        Criteria criteria = new Criteria();



        // Se agrega el criteria por proyecto.

        criteria.addEqualTo("owner", Integer.valueOf("" + memberId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));


        // Query of all the teams

        Query query = new QueryByCriteria(projectsData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        Iterator e = allLines.iterator();

        //broker.close();

        // Se actualiza cada entrada

        projectsData data;

        while (e.hasNext()) {

            data = (projectsData) e.next();

            projectsData dataNew = new projectsData(data);

            dataNew.setowner(1); // Usuario admin por definicion!! 

            this.update(dataNew);

        }


    }

    /*
     * Metodo que transfiere todos los proyectos del usuario dado al administrador
     */
    public void deleteAllReferences(int memberId, int idAccount) throws PersistenceBrokerException {

        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("owner", Integer.valueOf("" + memberId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the teams
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // Se abren los brokers necesarios.
        costsBroker costBroker = new costsBroker();
        topicsBroker topicBroker = new topicsBroker();
        tasksBroker taskBroker = new tasksBroker();
        filesBroker fileBroker = new filesBroker();
        projectsData dataDel;

        // Borra cada entrada
        while (e.hasNext()) {
            dataDel = (projectsData) e.next();

            // Se borran los costos
            costBroker.deleteAllReferencesByProject(dataDel.getid(), idAccount);
            topicBroker.deleteAllReferencesByProject(dataDel.getid(), idAccount);
            taskBroker.deleteAllReferencesByProject(dataDel.getid(), idAccount);
            fileBroker.deleteAllReferencesByProject(dataDel.getid(), idAccount);

            // Se borra el proyecto
            this.delete(dataDel);
        }

        //broker.close();
        // Se cierran los brokers.
        costBroker.close();
        topicBroker.close();
        taskBroker.close();
        fileBroker.close();

    }

    /*
     * Metodo que transfiere todos los proyectos del usuario dado al administrador
     */
    public void deleteAllReferencesbyAccount(int accountId) throws PersistenceBrokerException {

        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("id_account", Integer.valueOf("" + accountId));

        // Query of all the teams
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // Se abren los brokers necesarios.
        costsBroker costBroker = new costsBroker();
        topicsBroker topicBroker = new topicsBroker();
        tasksBroker taskBroker = new tasksBroker();
        filesBroker fileBroker = new filesBroker();
        projectsData dataDel;

        // Borra cada entrada
        while (e.hasNext()) {
            dataDel = (projectsData) e.next();

            // Se borran los costos
            costBroker.deleteAllReferencesByProject(dataDel.getid(), accountId);
            topicBroker.deleteAllReferencesByProject(dataDel.getid(), accountId);
            taskBroker.deleteAllReferencesByProject(dataDel.getid(), accountId);
            fileBroker.deleteAllReferencesByProject(dataDel.getid(), accountId);

            // Se borra el proyecto
            this.delete(dataDel);
        }
        // Se cierran los brokers.
        //broker.close();
        costBroker.close();
        topicBroker.close();
        taskBroker.close();
        fileBroker.close();

    }

    /*
     * Metodo que transfiere todos los proyectos del usuario dado al administrador
     */
    public void deleteAllReferencesByOrganization(int orgId, int idAccount) throws Exception {

        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("organization", Integer.valueOf("" + orgId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the teams
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // Se abren los brokers necesarios.
        costsBroker costBroker = new costsBroker();
        topicsBroker topicBroker = new topicsBroker();
        tasksStatusLogBroker tslBroker= new tasksStatusLogBroker();
        tasksBroker taskBroker = new tasksBroker();
        filesBroker fileBroker = new filesBroker();
        projectsData dataDel;

        // Borra cada entrada
        while (e.hasNext()) {
            dataDel = (projectsData) e.next();

            // Se borran los costos
            costBroker.deleteAllReferencesByProject(dataDel.getid(), idAccount);
            topicBroker.deleteAllReferencesByProject(dataDel.getid(), idAccount);
            tslBroker.deleteAllReferencesByProject(dataDel.getid(), idAccount);
            taskBroker.deleteAllReferencesByProject(dataDel.getid(), idAccount);
            fileBroker.deleteAllReferencesByProject(dataDel.getid(), idAccount);

            // Se borra el proyecto
            this.delete(dataDel);
        }
        // Se cierran los brokers.
        //broker.close();
        costBroker.close();
        topicBroker.close();
        taskBroker.close();
        fileBroker.close();

    }

    /* Regresa la lista de todos los proyectos en los cuales el miembro indicado
     * forma parte del equipo y ademas, el proyecto esta publicado*/
    public Iterator getListByMemberForProject(String sortColumnName, String sortOrder, int idMember, int page, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();

        // PASO #01.  Se extraen todos los proyectos en donde el miembro

        // indicado no es el dueño, pero pertenece a este proyecto por medio

        // del equipo

        criteria = new Criteria();

        //      criteria.addEqualTo("published", "1");               

        criteria.addEqualTo("detailTeams.parentMember.id",
                Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        // Query of all the projects

        Query query = new QueryByCriteria(projectsData.class, criteria);
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        //broker.close();
        // Se modifica el total de registros retornados para efectos
        // del paginado.
        return allLines.iterator();

    }
       /* Regresa una lista de todas los proyectos asociadas con member especificado */
    public void getMembersByProject1(String id, Hashtable hashProjects, int idAccount) throws PersistenceBrokerException {
          Connection conn = null;
        ResultSet rs = null;
        Statement stmt1 = null;
        projectsData projData= new projectsData();
        String query="";
        query="SELECT projects.id,projects.organization," +
"projects.owner,projects.priority,projects.status,projects.name,projects.description,projects.created,projects.modified,projects.published," +
"projects.upload_max,projects.published_assigned,projects.published_endtask,projects.start_date,projects.end_date,projects.id_account," +
"projects.project_id,projects.sec_projects,projects.send_email,projects.autom_notification "+
                 "from projects, teams WHERE projects.id_account="+ idAccount + " AND projects.status IN (2,3) AND teams.members="+id+
                 " AND teams.projects=projects.id ORDER BY projects.name ASC";
            
        connectionClass _conecctionClass = new connectionClass();
        conn = _conecctionClass.getConnection();
        try {             
            stmt1 = conn.createStatement();
            rs = stmt1.executeQuery(query);
              while (rs.next()) {
                  projData= new projectsData();
                projData.setid(rs.getInt("id"));
                projData.setorganization(rs.getInt("organization"));
                projData.setowner(rs.getInt("owner"));
                projData.setpriority(rs.getInt("priority"));
                projData.setstatus(rs.getInt("status"));
                projData.setname(rs.getString("name"));
                projData.setdescription(rs.getString("description"));
                projData.setcreated(rs.getTimestamp("created"));
                projData.setmodified(rs.getTimestamp("modified"));
                projData.setpublished(rs.getString("published"));
                projData.setupload_max(rs.getString("upload_max"));
                projData.setpublished_assigned(rs.getString("published_assigned"));
                projData.setpublished_endtask(rs.getString("published_endtask"));
                projData.setstart_date(rs.getTimestamp("start_date"));
                projData.setstart_date(rs.getTimestamp("end_date"));
                projData.setId_account(rs.getInt("id_account"));
                projData.setProject_id(rs.getInt("project_id"));
                projData.setSec_projects(rs.getString("sec_projects"));
                projData.setSend_email(rs.getString("send_email"));
                projData.setautom_notification(rs.getString("autom_notification"));
                 hashProjects.put("" + rs.getInt("id"), projData);
            
              }
        } catch (SQLException ex) {
            ex.printStackTrace();
              try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
        }
            try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
    }
       /* Regresa una lista de todas los proyectos asociadas con member especificado */
    public void getMembersByProject2(String id, ArrayList listProjects, int idAccount) throws PersistenceBrokerException {
          Connection conn = null;
        ResultSet rs = null;
        Statement stmt1 = null;
        projectsData projData= new projectsData();
        String query="";
        query="SELECT projects.id,projects.organization," +
"projects.owner,projects.priority,projects.status,projects.name,projects.description,projects.created,projects.modified,projects.published," +
"projects.upload_max,projects.published_assigned,projects.published_endtask,projects.start_date,projects.end_date,projects.id_account," +
"projects.project_id,projects.sec_projects,projects.send_email,projects.autom_notification "+
                 "from projects, teams WHERE projects.id_account="+ idAccount + " AND teams.members="+id+
                 " AND teams.projects=projects.id ORDER BY projects.name ASC";
            
        connectionClass _conecctionClass = new connectionClass();
        conn = _conecctionClass.getConnection();
        try {             
            stmt1 = conn.createStatement();
            rs = stmt1.executeQuery(query);
              while (rs.next()) {
                  projData= new projectsData();
                projData.setid(rs.getInt("id"));
                projData.setorganization(rs.getInt("organization"));
                projData.setowner(rs.getInt("owner"));
                projData.setpriority(rs.getInt("priority"));
                projData.setstatus(rs.getInt("status"));
                projData.setname(rs.getString("name"));
                projData.setdescription(rs.getString("description"));
                projData.setcreated(rs.getTimestamp("created"));
                projData.setmodified(rs.getTimestamp("modified"));
                projData.setpublished(rs.getString("published"));
                projData.setupload_max(rs.getString("upload_max"));
                projData.setpublished_assigned(rs.getString("published_assigned"));
                projData.setpublished_endtask(rs.getString("published_endtask"));
                projData.setstart_date(rs.getTimestamp("start_date"));
                projData.setstart_date(rs.getTimestamp("end_date"));
                projData.setId_account(rs.getInt("id_account"));
                projData.setProject_id(rs.getInt("project_id"));
                projData.setSec_projects(rs.getString("sec_projects"));
                projData.setSend_email(rs.getString("send_email"));
                projData.setautom_notification(rs.getString("autom_notification"));
                 listProjects.add(projData);
            
              }
        } catch (SQLException ex) {
            ex.printStackTrace();
              try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
        }
            try {
                  conn.close();
              } catch (SQLException ex1) {
                  ex1.printStackTrace();
              }
    }
    
    /* Regresa una lista de todas los proyectos asociadas con member especificado */
    public void getMembersByProject(String id, projectsBroker brokerProjects, Hashtable hashProjects, int idAccount) throws PersistenceBrokerException {
        teamsData teamData = new teamsData();
        //membersData memberData = new membersData();
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("members", id);
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // Query of all the tasks
        Query query = new QueryByCriteria(teamsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        Iterator e = allLines.iterator();
        projectsData projectData = new projectsData();
        while (e.hasNext()) {
            projectData = new projectsData();
            teamData = (teamsData) e.next();
            // Los guardamos en un hash para que elimine de una vez los duplicados.
            projectData = (projectsData) brokerProjects.getData(teamData.getprojects(), idAccount);
            if (projectData.getstatus() == 2 || projectData.getstatus() == 3) {
                hashProjects.put("" + teamData.getprojects(), projectData);
            }
        }
        //broker.close();
    }

    public Iterator getListSubProj(int idProject, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering

        Criteria criteria = new Criteria();

        // We order the result set

        criteria.addEqualTo("project_id", new Integer(idProject));
        criteria.addEqualTo("id_account", new Integer(idAccount));
        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);
        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result 
    //broker.close();
        return allLines.iterator();
    }

    public boolean isOwner(int idMember, int idProject, int accountId) throws PersistenceBrokerException {

        // New criteria for sortering
        Criteria criteria = new Criteria();
        boolean value = false;

        criteria.addEqualTo("owner", new Integer(idMember));

        criteria.addEqualTo("id_account", new Integer(accountId));

        criteria.addEqualTo("id", new Integer(idProject));

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);
        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        if (allLines.size() > 0) {
            value = true;
        }



        return value;

    }

    public Iterator getListByMember(String sortColumnName, String sortOrder, int idMember,
            int accountId) throws PersistenceBrokerException {

        // New criteria for sortering
        Criteria criteria = new Criteria();

        // PASO #01.  Se extraen todos los proyectos en donde el miembro
        // indicado es el dueño.                
        // Se listan todo los proyectos si el usuario admin 24/03/04

        criteria.addEqualTo("owner", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", new Integer(accountId));

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // PASO #02.  Se extraen todos los proyectos en donde el miembro
        // indicado no es el dueño, pero pertenece a este proyecto por medio
        // del equipo.  
        // Modificacion Jury:  Este paso se da solo si no es el admin que ya tiene
        // la condicion de listar todos los proyectos activos


        criteria = new Criteria();
        criteria.addNotEqualTo("owner", Integer.valueOf("" + idMember));
        criteria.addEqualTo("detailTeams.parentMember.id", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", Integer.valueOf("" + accountId));
        criteria.addEqualTo("project_id", Integer.valueOf("0"));
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        // Query of all the projects
        query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines2 = broker.getCollectionByQuery(query);

        // PASO # 03. Se debe hacer un merge entre los dos Collections
        // allLines y allLines2 
        allLines.addAll(allLines2);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        //broker.close();
        return allLines.iterator();

    }

    
        public Iterator getListOfActiveProyectsByMember(String sortColumnName, String sortOrder, int idMember,
            int accountId) throws PersistenceBrokerException {

        // New criteria for sortering
        Criteria criteria = new Criteria();

        // PASO #01.  Se extraen todos los proyectos en donde el miembro
        // indicado es el dueño.                
        // Se listan todo los proyectos si el usuario admin 24/03/04

        criteria.addEqualTo("owner", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", new Integer(accountId));
   // Solo los proyectos activos.

        criteria.addEqualTo("status", "3");
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Query of all the projects
        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // PASO #02.  Se extraen todos los proyectos en donde el miembro
        // indicado no es el dueño, pero pertenece a este proyecto por medio
        // del equipo.  
        // Modificacion Jury:  Este paso se da solo si no es el admin que ya tiene
        // la condicion de listar todos los proyectos activos


        criteria = new Criteria();
        criteria.addNotEqualTo("owner", Integer.valueOf("" + idMember));
        criteria.addEqualTo("detailTeams.parentMember.id", Integer.valueOf("" + idMember));
        criteria.addEqualTo("id_account", Integer.valueOf("" + accountId));
        criteria.addEqualTo("project_id", Integer.valueOf("0"));
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        // Query of all the projects
        query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines2 = broker.getCollectionByQuery(query);

        // PASO # 03. Se debe hacer un merge entre los dos Collections
        // allLines y allLines2 
        allLines.addAll(allLines2);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));


        //broker.close();
        return allLines.iterator();

    }
        
        public mainData getDataByName(String name, int idAccount) throws PersistenceBrokerException {


        projectsData data = new projectsData();
        // New criteria for sortering

        Criteria criteria = new Criteria();

        System.out.println(String.valueOf(name));
        criteria.addEqualTo("name", String.valueOf(name));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        System.out.println(String.valueOf(idAccount));
        // Query of all the projects

        Query query = new QueryByCriteria(projectsData.class, criteria);

        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result

        //broker.close();
         Iterator e = allLines.iterator();
        data= (projectsData)e.next();
        return data;

    }
    
   
}
