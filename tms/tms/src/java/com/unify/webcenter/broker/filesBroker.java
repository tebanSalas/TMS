//   Generated by FlechaRoja Tech Tools (2003) 
package com.unify.webcenter.broker;

import com.unify.webcenter.data.*;
import org.apache.ojb.broker.query.*;
import org.apache.ojb.broker.*;
import com.unify.webcenter.conf.TMSConfigurator;
import com.unify.webcenter.desencrypter.DesEncrypter;
import java.util.*;
import java.io.*;
/**
 * Class that represent the broker for the table files
 * @author Administrator
 */
public class filesBroker extends MainBroker {

    public java.util.Iterator getList(int accountId) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", new Integer(accountId));

        // Query of all the files

        Query query = new QueryByCriteria(filesData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        // now iterate over the result to print each Service

        return allLines.iterator();

    }

    public java.util.Iterator getList(String sortColumnName, String sortOrder) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        // Query of all the assignments
        Query query = new QueryByCriteria(filesData.class, criteria);
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        // now iterate over the result 
        return allLines.iterator();
    }

    public java.util.Iterator getList(String sortColumnName, String sortOrder, int accountId) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();



        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }


        criteria.addEqualTo("id_account", new Integer(accountId));
        // Query of all the files

        Query query = new QueryByCriteria(filesData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        // now iterate over the result 

        return allLines.iterator();

    }

    // Regresa una lista ordenada de todos los files que estan asociados a 

    // una tarea.
    public java.util.Iterator getList(String sortColumnName,
            String sortOrder, int parentTask, int page, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();



        // Se filtra por la tarea asociada, nunca se despliegan todos los

        // files de forma irrestricta.

        criteria.addEqualTo("task", Integer.valueOf("" + parentTask));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));


        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }



        // Query of all the files

        Query query = new QueryByCriteria(filesData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        // Se modifica el total de registros retornados para efectos

        // del paginado.

        setCount(new Integer(allLines.size()));



        if (page > 0) {

            // Se determinan los limites superior e inferior

            int inicio = (page - 1) * GAP_SIZE;

            int fin = page * GAP_SIZE;



            // now iterate over the result 

            return getCollection(allLines, inicio, fin);

        } else {

            return allLines.iterator();

        }

    }

    // Return the object associated with the key.
    public mainData getData(int id, int idAccount) {

        filesData data = new filesData();

        Criteria criteria = new Criteria();

        criteria.addEqualTo("id", new Integer(id));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));


        // Query of the exact organization

        Query query = new QueryByCriteria(filesData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // If exists the record -MUST EXISTS ALWAYS

        if (e.hasNext()) {
            data = (filesData) e.next();
        }



        // We return the object

        return data;

    }

    // Return the object associated with the key.
    public mainData getData(int id) {

        filesData data = new filesData();

        Criteria criteria = new Criteria();

        criteria.addEqualTo("id", new Integer(id));



        // Query of the exact organization

        Query query = new QueryByCriteria(filesData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // If exists the record -MUST EXISTS ALWAYS

        if (e.hasNext()) {
            data = (filesData) e.next();
        }



        // We return the object

        return data;

    }

    // Regresa una lista ordenada de todos los files que estan asociados a 
    // un proyecto
    public java.util.Iterator getListByProject(String sortColumnName,
            String sortOrder, int projectId, int page, int idAccount) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se filtra por la tarea asociada, nunca se despliegan todos los
        // files de forma irrestricta.
        criteria.addEqualTo("project", Integer.valueOf("" + projectId));
      //  criteria.addEqualTo("task", Integer.valueOf("0"));
        criteria.addEqualTo("id_account", new Integer(idAccount));
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Query of all the files
        Query query = new QueryByCriteria(filesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        System.out.println("Pages: "+page );
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    // Regresa una lista ordenada de todos los files que estan asociados a 

    // un proyecto y que estan publicados
    public java.util.Iterator getListByProjectForPortal(String sortColumnName,
            String sortOrder, int projectId, int page, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();



        // Se filtra por la tarea asociada, nunca se despliegan todos los

        // files de forma irrestricta.

        criteria.addEqualTo("project", Integer.valueOf("" + projectId));

        criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));


        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }



        // Query of all the files

        Query query = new QueryByCriteria(filesData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        // Se modifica el total de registros retornados para efectos

        // del paginado.

        setCount(new Integer(allLines.size()));



        if (page > 0) {

            // Se determinan los limites superior e inferior

            int inicio = (page - 1) * GAP_SIZE;

            int fin = page * GAP_SIZE;



            // now iterate over the result 

            return getCollection(allLines, inicio, fin);

        } else {

            return allLines.iterator();

        }

    }

    // Regresa una lista ordenada de todos los files que estan asociados a 

    // una tarea y que estan publicados
    public java.util.Iterator getListByTaskForPortal(String sortColumnName,
            String sortOrder, int taskId, int page, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering

        Criteria criteria = new Criteria();



        // Se filtra por la tarea asociada, nunca se despliegan todos los

        // files de forma irrestricta.

        criteria.addEqualTo("task", Integer.valueOf("" + taskId));

        criteria.addEqualTo("published", "1");
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));


        // We order the result set

        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }



        // Query of all the files

        Query query = new QueryByCriteria(filesData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        // Se modifica el total de registros retornados para efectos

        // del paginado.

        setCount(new Integer(allLines.size()));



        if (page > 0) {

            // Se determinan los limites superior e inferior

            int inicio = (page - 1) * GAP_SIZE;

            int fin = page * GAP_SIZE;



            // now iterate over the result 

            return getCollection(allLines, inicio, fin);

        } else {

            return allLines.iterator();

        }

    }

    // Regresa una lista ordenada de todos los files que estan asociados a 
    // un topico
    public java.util.Iterator getListByTopic(String sortColumnName,
            String sortOrder, int topicId, int page, int idAccount) throws PersistenceBrokerException {

        // New criteria for sortering
        Criteria criteria = new Criteria();

        // Se filtra por la tarea asociada, nunca se despliegan todos los
        // files de forma irrestricta.
        criteria.addEqualTo("topic", Integer.valueOf("" + topicId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }

        // Query of all the files
        Query query = new QueryByCriteria(filesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // Se modifica el total de registros retornados para efectos
        // del paginado.
        setCount(new Integer(allLines.size()));

        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE;
            int fin = page * GAP_SIZE;

            // now iterate over the result 
            return getCollection(allLines, inicio, fin);
        } else {
            return allLines.iterator();
        }
    }

    /*
     * Metodo que transfiere todos los files del usuario dado al dueï¿½o del proyecto
     * al que pertenece.
     */
    public void transferAllReferences(int memberId, int idAccount) throws PersistenceBrokerException {

        // New criteria for search

        Criteria criteria = new Criteria();



        // Se agrega el criteria por proyecto.

        criteria.addEqualTo("owner", Integer.valueOf("" + memberId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));


        // Query of all the teams

        Query query = new QueryByCriteria(filesData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        Iterator e = allLines.iterator();



        // Se actualiza cada entrada y se reapunta al duenno del proyecto.

        filesData data;

        projectsData projData;

        projectsBroker projBroker = new projectsBroker();

        while (e.hasNext()) {

            data = (filesData) e.next();

            projData = (projectsData) projBroker.getData(data.getproject(), idAccount);

            data.setowner(projData.getowner()); // Usuario admin por definicion!!

            this.update(data);

        }

        projBroker.close();

    }

    /*
     * Metodo que elimina todas las referencias de las tareas de un proyecto
     */
    public void deleteAllReferencesByProject(int projectId, int idAccount) throws PersistenceBrokerException {

        // New criteria for search

        Criteria criteria = new Criteria();



        // Se agrega el criteria por el dueï¿½o
        criteria.addEqualTo("project", Integer.valueOf("" + projectId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        // Query of all the proyectos

        Query query = new QueryByCriteria(filesData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        Iterator e = allLines.iterator();



        String sub = TMSConfigurator.getDownloadPath();

        String separator = File.separator;

        // Si el string no termina con el separador de files, se agrgega

        if (!sub.endsWith(separator)) {
            sub = sub + separator;
        }

        String fullpath = "";

        String subdir = "";

        File theFile;



        // delete each file entry in DB and your file asociated.

        String fileName = "";

        filesData datatemp = new filesData();

        // Se borra cada entrada

        while (e.hasNext()) {

            datatemp = (filesData) e.next();

            subdir = sub;

            fileName = datatemp.getid() + "-" + datatemp.getname();


            // Se forma la ruta del archivo fisico

            if (datatemp.getproject() > 0) {

                subdir = subdir + "PR" + datatemp.getproject() + separator;

                if (datatemp.gettask() > 0) {
                    subdir = subdir + "TK" + datatemp.gettask() + separator;
                }

                if (datatemp.gettopic() > 0) {
                    subdir = subdir + "TP" + datatemp.gettopic() + separator;
                }

            }

            // delete the file en la ruta dada

            fullpath = subdir + fileName;

            theFile = new File(fullpath);

            theFile.delete();


            // Se borra el registro.

            this.delete(datatemp);

        }

    }

    public void encryptFilebyProject(int projectId, int idAccount, String key) throws PersistenceBrokerException {
        try {
            // New criteria for search

            Criteria criteria = new Criteria();



            // Se agrega el criteria por el dueï¿½o
            criteria.addEqualTo("project", Integer.valueOf("" + projectId));
            criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

            // Query of all the proyectos

            Query query = new QueryByCriteria(filesData.class, criteria);



            // ask the broker to retrieve the Extent collection

            Collection allLines = broker.getCollectionByQuery(query);



            Iterator e = allLines.iterator();



            String sub = TMSConfigurator.getDownloadPath();

            String separator = File.separator;

            // Si el string no termina con el separador de files, se agrgega

            if (!sub.endsWith(separator)) {
                sub = sub + separator;
            }

            String fullpath = "";

            String subdir = "";
            String subdirTask = "";
            String subdirTopics = "";

            File theFile;



            // delete each file entry in DB and your file asociated.

            String fileName = "";

            filesData datatemp = new filesData();

            // Create encrypter/decrypter class
            DesEncrypter encrypter = new DesEncrypter(key);
            // Se encripta cada archivo

            while (e.hasNext()) {

                datatemp = (filesData) e.next();

                subdir = sub;
                subdirTask = sub;
                subdirTopics = sub;

              
                fileName = datatemp.getid() + "-" + datatemp.getname();


                // Se forma la ruta del archivo fisico

                if (datatemp.getproject() > 0 && datatemp.gettask() == 0) {

                    subdir = subdir + "PR" + datatemp.getproject() + separator;

                    fullpath = subdir + fileName;

                    String temp = fullpath.replace('.', '-');
                    String[] split = fullpath.split("-");
                    String fullpath2 = subdir + "temp" + split[1].toString();
                    theFile = new File(fullpath);
                    File theFile2 = new File(fullpath2);

                    // Encrypt
                    encrypter.encrypt(new FileInputStream(theFile),
                            new FileOutputStream(theFile2));

                    //write the file to the file specified
                    OutputStream bos = new FileOutputStream(theFile);
                    InputStream stream = new FileInputStream(theFile2);
                    int bytesRead = 0;
                    byte[] buffer = new byte[8192];
                    while ((bytesRead = stream.read(buffer, 0, 8192)) != -1) {
                        bos.write(buffer, 0, bytesRead);
                    }
                    stream.close();
                    bos.close();
                    theFile2.delete();
                }

                if (datatemp.gettask() > 0) {
                  

                    subdirTask = subdirTask + "PR" + datatemp.getproject() + separator + "TK" + datatemp.gettask() + separator;
                    fullpath = subdirTask + fileName;
                    System.out.println("fullpath");
                    System.out.println(fullpath);
                    String temp = fullpath.replace('.', '-');
                    String[] split = fullpath.split("-");
                    String fullpath2 = subdir + "temp" + split[1].toString();
                    theFile = new File(fullpath);
                    File theFile2 = new File(fullpath2);

                    // Encrypt
                    encrypter.encrypt(new FileInputStream(theFile),
                            new FileOutputStream(theFile2));

                    //write the file to the file specified
                    OutputStream bos = new FileOutputStream(theFile);
                    InputStream stream = new FileInputStream(theFile2);
                    int bytesRead = 0;
                    byte[] buffer = new byte[8192];
                    while ((bytesRead = stream.read(buffer, 0, 8192)) != -1) {
                        bos.write(buffer, 0, bytesRead);
                    }
                    stream.close();
                    bos.close();
                    theFile2.delete();
                }


                if (datatemp.gettopic() > 0) {
                    subdirTopics = subdirTopics + "PR" + datatemp.getproject() + separator + "TP" + datatemp.gettopic() + separator;
                    fullpath = subdirTopics + fileName;

                    String temp = fullpath.replace('.', '-');
                    String[] split = fullpath.split("-");
                    String fullpath2 = subdir + "temp" + split[1].toString();
                    theFile = new File(fullpath);
                    File theFile2 = new File(fullpath2);

                    // Encrypt
                    encrypter.encrypt(new FileInputStream(theFile),
                            new FileOutputStream(theFile2));

                    //write the file to the file specified
                    OutputStream bos = new FileOutputStream(theFile);
                    InputStream stream = new FileInputStream(theFile2);
                    int bytesRead = 0;
                    byte[] buffer = new byte[8192];
                    while ((bytesRead = stream.read(buffer, 0, 8192)) != -1) {
                        bos.write(buffer, 0, bytesRead);
                    }
                    stream.close();
                    bos.close();
                    theFile2.delete();

                }


            // delete the file en la ruta dada



            }
        } catch (Exception e) {
        }

    }

    public void desencryptFilebyProject(int projectId, int idAccount, String key) throws PersistenceBrokerException {
        try {
            // New criteria for search

            Criteria criteria = new Criteria();



            // Se agrega el criteria por el dueï¿½o
            criteria.addEqualTo("project", Integer.valueOf("" + projectId));
            criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

            // Query of all the proyectos

            Query query = new QueryByCriteria(filesData.class, criteria);



            // ask the broker to retrieve the Extent collection

            Collection allLines = broker.getCollectionByQuery(query);



            Iterator e = allLines.iterator();



            String sub = TMSConfigurator.getDownloadPath();
            String des = TMSConfigurator.getDesencryptFiles();
            String separator = File.separator;

            // Si el string no termina con el separador de files, se agrgega

            if (!sub.endsWith(separator)) {
                sub = sub + separator;
            }

            if (!des.endsWith(separator)) {
                des = des + separator;
            }

            String fullpath = "";

            String subdir = "";
            String subdirTask = "";
            String subdirTopics = "";

            File theFile;



            // delete each file entry in DB and your file asociated.

            String fileName = "";

            filesData datatemp = new filesData();

            // Create encrypter/decrypter class
            DesEncrypter encrypter = new DesEncrypter(key);
            // Se encripta cada archivo

            while (e.hasNext()) {
                
                datatemp = (filesData) e.next();
            
                subdir = sub;
                subdirTask = sub;
                subdirTopics = sub;
              
                fileName = datatemp.getid() + "-" + datatemp.getname();


                // Se forma la ruta del archivo fisico

                if (datatemp.getproject() > 0 && datatemp.gettask()==0 && datatemp.gettopic()==0) {

                    subdir = subdir + "PR" + datatemp.getproject() + separator;

                    fullpath = subdir + fileName;

                    String temp = fullpath.replace('.', '-');
                    String[] split = fullpath.split("-");
                    String fullpath2 = subdir + "temp" + split[1].toString();
                    theFile = new File(fullpath);
                    File theFile2 = new File(fullpath2);
                    // decrypt
                    encrypter.decrypt(new FileInputStream(theFile),
                            new FileOutputStream(theFile2));
                  
                    //save files in different dir
                    fullpath = des + fileName;
                 
                    theFile = new File(fullpath);
                    // Create directory for the file, if requested.
                    if (theFile.getParentFile() != null) {
                        theFile.getParentFile().mkdirs();
                    }

                 
                    //write the file to the file specified
                    OutputStream bos = new FileOutputStream(theFile);
                    InputStream stream = new FileInputStream(theFile2);
                    int bytesRead = 0;
                    byte[] buffer = new byte[8192];
                    while ((bytesRead = stream.read(buffer, 0, 8192)) != -1) {
                        bos.write(buffer, 0, bytesRead);
                    }
                    stream.close();
                    bos.close();
                    theFile2.delete();
                }

                if (datatemp.gettask() > 0) {
                
                    subdirTask = subdirTask + "PR" + datatemp.getproject() + separator + "TK" + datatemp.gettask() + separator;
                    fullpath = subdirTask + fileName;
                
                    String temp = fullpath.replace('.', '-');
                    String[] split = fullpath.split("-");
                    String fullpath2 = subdir + "temp" + split[1].toString();
                    theFile = new File(fullpath);
                    File theFile2 = new File(fullpath2);
                   

                    // decrypt
                    encrypter.decrypt(new FileInputStream(theFile),
                            new FileOutputStream(theFile2));
               
                    //save files in different dir
                    fullpath = des + fileName;
                
                    theFile = new File(fullpath);
 // Create directory for the file, if requested.
                        if (theFile.getParentFile() != null) {
                            theFile.getParentFile().mkdirs();
                        }

                  
                    //write the file to the file specified
                    OutputStream bos = new FileOutputStream(theFile);
                    InputStream stream = new FileInputStream(theFile2);
                    int bytesRead = 0;
                    byte[] buffer = new byte[8192];
                    while ((bytesRead = stream.read(buffer, 0, 8192)) != -1) {
                        bos.write(buffer, 0, bytesRead);
                    }
                    stream.close();
                    bos.close();
                    theFile2.delete();
                }

                if (datatemp.gettopic() > 0) {
                    
                    subdirTopics = subdirTopics + "PR" + datatemp.getproject() + separator + "TP" + datatemp.gettopic() + separator;
                  
                    fullpath = subdirTopics + fileName;

                    String temp = fullpath.replace('.', '-');
                    String[] split = fullpath.split("-");
                    String fullpath2 = subdir + "temp" + split[1].toString();
                    theFile = new File(fullpath);
                    File theFile2 = new File(fullpath2);
                    // decrypt
                    encrypter.decrypt(new FileInputStream(theFile),
                            new FileOutputStream(theFile2));
                    //save files in different dir
                    fullpath = des + fileName;
                    theFile = new File(fullpath);
                        // Create directory for the file, if requested.
                        if (theFile.getParentFile() != null) {
                            theFile.getParentFile().mkdirs();
                        }

               
                    //write the file to the file specified
                    OutputStream bos = new FileOutputStream(theFile);
                    InputStream stream = new FileInputStream(theFile2);
                    int bytesRead = 0;
                    byte[] buffer = new byte[8192];
                    while ((bytesRead = stream.read(buffer, 0, 8192)) != -1) {
                        bos.write(buffer, 0, bytesRead);
                    }
                    stream.close();
                    bos.close();
                    theFile2.delete();

                }


            }
        } catch (Exception e) {
        }

    }

    public void deleteAllReferencesByOwner(int memberId, int idAccount) throws PersistenceBrokerException {

        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por el dueï¿½o
        criteria.addEqualTo("owner", Integer.valueOf("" + memberId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the teams
        Query query =
                new QueryByCriteria(filesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();
        String sub = TMSConfigurator.getDownloadPath();
        String separator = File.separator;

        // Si el string no termina con el separador de files, se agrgega





        if (!sub.endsWith(separator)) {
            sub = sub + separator;
        }

        String fullpath = "";
        String subdir = "";
        File theFile;

        // delete each file entry in DB and your file asociated.
        String fileName = "";
        filesData datatemp = new filesData();

        // Se borra cada entrada
        while (e.hasNext()) {
            datatemp = (filesData) e.next();
            subdir = sub;
            fileName = datatemp.getid() + "-" + datatemp.getname();


            // Se forma la ruta del archivo fisico
            if (datatemp.getproject() > 0) {
                subdir = subdir + "PR" + datatemp.getproject() + separator;
                if (datatemp.gettask() > 0) {
                    subdir = subdir + "TK" + datatemp.gettask() + separator;
                }
                if (datatemp.gettopic() > 0) {
                    subdir = subdir + "TP" + datatemp.gettopic() + separator;
                }
            }

            // delete the file en la ruta dada
            fullpath = subdir + fileName;
            theFile = new File(fullpath);
            theFile.delete();

            // Se borra el registro.
            this.delete(datatemp);
        }
    }

    public void deleteAllReferencesbyAccount(int accountId) throws PersistenceBrokerException {

        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por el dueï¿½o
        criteria.addEqualTo("id_account", Integer.valueOf("" + accountId));

        // Query of all the teams
        Query query =
                new QueryByCriteria(filesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();
        String sub = TMSConfigurator.getDownloadPath();
        String separator = File.separator;

        // Si el string no termina con el separador de files, se agrgega


        if (!sub.endsWith(separator)) {
            sub = sub + separator;
        }

        String fullpath = "";
        String subdir = "";
        File theFile;

        // delete each file entry in DB and your file asociated.
        String fileName = "";
        filesData datatemp = new filesData();

        // Se borra cada entrada
        while (e.hasNext()) {
            datatemp = new filesData();
            datatemp = (filesData) e.next();
            subdir = sub;
            fileName = datatemp.getid() + "-" + datatemp.getname();

            
            // Se forma la ruta del archivo fisico
            if (datatemp.getproject() > 0) {
                subdir = subdir + "PR" + datatemp.getproject() + separator;
                if (datatemp.gettask() > 0) {
                    subdir = subdir + "TK" + datatemp.gettask() + separator;
                }
                if (datatemp.gettopic() > 0) {
                    subdir = subdir + "TP" + datatemp.gettopic() + separator;
                }
            }

            // delete the file en la ruta dada
            fullpath = subdir + fileName;
            System.out.println(fullpath);
            theFile = new File(fullpath);
            theFile.delete();

            // Se borra el registro.
            this.delete(datatemp);
        }
    }
    
      public void deleteAllReferencesByTask(int taskId, int projectId, int idAccount) throws PersistenceBrokerException {

        // New criteria for search

        Criteria criteria = new Criteria();



        // Se agrega el criteria por el dueï¿½o
        criteria.addEqualTo("project", Integer.valueOf("" + projectId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
         criteria.addEqualTo("task", Integer.valueOf("" + taskId));

        // Query of all the proyectos

        Query query = new QueryByCriteria(filesData.class, criteria);



        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);



        Iterator e = allLines.iterator();



        String sub = TMSConfigurator.getDownloadPath();

        String separator = File.separator;

        // Si el string no termina con el separador de files, se agrgega

        if (!sub.endsWith(separator)) {
            sub = sub + separator;
        }

        String fullpath = "";

        String subdir = "";

        File theFile;



        // delete each file entry in DB and your file asociated.

        String fileName = "";

        filesData datatemp = new filesData();

        // Se borra cada entrada

        while (e.hasNext()) {

            datatemp = (filesData) e.next();

            subdir = sub;

            fileName = datatemp.getid() + "-" + datatemp.getname();


            // Se forma la ruta del archivo fisico

            if (datatemp.getproject() > 0) {

                subdir = subdir + "PR" + datatemp.getproject() + separator;

                if (datatemp.gettask() > 0) {
                    subdir = subdir + "TK" + datatemp.gettask() + separator;
                }
            }

            // delete the file en la ruta dada

            fullpath = subdir + fileName;

            theFile = new File(fullpath);

            theFile.delete();


            // Se borra el registro.

            this.delete(datatemp);

        }

    }
      
      public void addProjectFiles(int baseProject, int targetProject, int idAccount){
        String sub = TMSConfigurator.getDownloadPath();
        String subDesc = TMSConfigurator.getDownloadPath();
        
        String sourceURL;
        String targetURL;

        String separator = File.separator;
          // Si el string no termina con el separador de files, se agrgega

        if (!sub.endsWith(separator)) {
            sub = sub + separator;
        }
        
        if (!subDesc.endsWith(separator)) {
            subDesc = subDesc + separator;
        }

        String fullpath = "";
         sub = sub + "PR"+baseProject;
         subDesc = subDesc + "PR"+targetProject;
         
             // New criteria for search
        filesBroker fBroker= new filesBroker();
        Criteria criteria = new Criteria();
        filesData data= new filesData();

        // Se agrega el criteria por el dueï¿½o
        criteria.addEqualTo("project", Integer.valueOf("" + baseProject));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        criteria.addEqualTo("task", "0");
        criteria.addEqualTo("topic", "0");
        // Query of all the proyectos

        Query query = new QueryByCriteria(filesData.class, criteria);

        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();
        File source= new File(sub);
        File desc= new File(subDesc);
        
        try {
                copyDirectory(source, desc);
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        
         sub = sub + separator;
         subDesc = subDesc + separator;
         
         sourceURL= sub;
         targetURL= subDesc;
        while (e.hasNext()){
            sub= sourceURL;
            subDesc=targetURL;
            
            data = (filesData) e.next();
            sub= sub+data.getid()+"-"+data.getname();
            data.setid(0);
            data.setproject(targetProject);
            fBroker.add(data);
            subDesc= subDesc+data.getid()+"-"+data.getname();
            source= new File(sub);
            desc= new File(subDesc);
            System.out.println("Files123: "+sub + " , "+ subDesc);
            try {
                copyDirectory(source, desc);
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
         
        
      /*  File source = new File(sub);
        File desc = new File(subDesc);
        
        try {
            copyDirectory(source , desc);
        } catch (IOException ex) {
            ex.printStackTrace();
        }*/
        
      }
      public void addTaskFiles(tasksData baseTask, tasksData targetTask){
        String sub = TMSConfigurator.getDownloadPath();
        String subDesc = TMSConfigurator.getDownloadPath();
        
        String sourceURL;
        String targetURL;

        String separator = File.separator;
          // Si el string no termina con el separador de files, se agrgega

        if (!sub.endsWith(separator)) {
            sub = sub + separator;
        }
        
        if (!subDesc.endsWith(separator)) {
            subDesc = subDesc + separator;
        }

        String fullpath = "";
         sub = sub + "PR"+baseTask.getproject()+ separator+"TK"+baseTask.getid();
         subDesc = subDesc + "PR"+targetTask.getproject()+ separator+"TK"+targetTask.getid();
         
             // New criteria for search
        filesBroker fBroker= new filesBroker();
        Criteria criteria = new Criteria();
        filesData data= new filesData();

        // Se agrega el criteria por el dueño
        criteria.addEqualTo("project", Integer.valueOf("" + baseTask.getproject()));
        criteria.addEqualTo("id_account", Integer.valueOf("" + baseTask.getId_account()));
        criteria.addEqualTo("task",  ""+baseTask.getid());
        criteria.addEqualTo("topic", "0");
        // Query of all the proyectos

        Query query = new QueryByCriteria(filesData.class, criteria);

        // ask the broker to retrieve the Extent collection

        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();
        File source= new File(sub);
        File desc= new File(subDesc);
        
            System.out.println("FilesTASK: "+sub + " , "+ subDesc);
        try {
                copyDirectory(source, desc);
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        
         sub = sub + separator;
         subDesc = subDesc + separator;
         
         sourceURL= sub;
         targetURL= subDesc;
        while (e.hasNext()){
            sub= sourceURL;
            subDesc=targetURL;
            
            data = (filesData) e.next();
            sub= sub+data.getid()+"-"+data.getname();
            data.setid(0);
            data.setproject(targetTask.getproject());
            data.settask(targetTask.getid());
            fBroker.add(data);
            subDesc= subDesc+data.getid()+"-"+data.getname();
            System.out.println("Origen: "+sub + " , Destino"+ subDesc);
            source= new File(sub);
            desc= new File(subDesc);
            System.out.println("Files123: "+sub + " , "+ subDesc);
            try {
                copyDirectory(source, desc);
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
         
        
      /*  File source = new File(sub);
        File desc = new File(subDesc);
        
        try {
            copyDirectory(source , desc);
        } catch (IOException ex) {
            ex.printStackTrace();
        }*/
        
      }
      public void copyDirectory(File sourceLocation , File targetLocation)
    throws IOException {
          File file;
        if (sourceLocation.isDirectory()) {
            if (!targetLocation.exists()) {
                targetLocation.mkdir();
            }

           /* String[] children = sourceLocation.list();
            for (int i=0; i<children.length; i++) {
                System.out.println("HIJO "+ children[i]);
                file=new File(sourceLocation, children[i]);
                if (!file.isDirectory()){
                copyDirectory(new File(sourceLocation, children[i]),
                        new File(targetLocation, children[i]));
                }
            }*/
        } else {
            InputStream in = new FileInputStream(sourceLocation);
            OutputStream out = new FileOutputStream(targetLocation);
            
            // Copy the bits from instream to outstream
            byte[] buf = new byte[1024];
            int len;
            while ((len = in.read(buf)) > 0) {
                out.write(buf, 0, len);
            }
            in.close();
            out.close();
        }
    }
}
