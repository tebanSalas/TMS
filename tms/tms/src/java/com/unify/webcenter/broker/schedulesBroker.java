//   Generated by FlechaRoja Tech Tools (2003)
package com.unify.webcenter.broker;

import com.unify.webcenter.data.*;

import java.math.BigDecimal;
import java.sql.ResultSet;
import org.apache.ojb.broker.query.*;
import org.apache.ojb.broker.*;
import java.util.*;

import java.util.ArrayList;

/**
 * Class that represent the broker for the table schedules
 * @author Administrator
 */
public class schedulesBroker extends MainBroker {

    public java.util.Iterator getList(int accountId) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", new Integer(accountId));
        // Query of all the schedules
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result to print each Service
        return allLines.iterator();
    }

    public java.util.Iterator getList(String sortColumnName, String sortOrder) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();
        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        // Query of all the assignments
        Query query = new QueryByCriteria(schedulesData.class, criteria);
        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        // now iterate over the result 
        return allLines.iterator();
    }

    public java.util.Iterator getList(String sortColumnName, String sortOrder, int accountId) throws PersistenceBrokerException {
        // New criteria for sortering
        Criteria criteria = new Criteria();

        // We order the result set
        if (sortOrder.equalsIgnoreCase("ASC")) {
            criteria.addOrderByAscending(sortColumnName);
        } else {
            criteria.addOrderByDescending(sortColumnName);
        }
        criteria.addEqualTo("id_account", new Integer(accountId));
        // Query of all the schedules
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result
        return allLines.iterator();
    }

    // Return the object associated with the key.
    public mainData getData(int id, int idAccount) {
        // We return null object, this method never could be used,
        // because the key of the table has a multi key.
        return null;
    }

    // Return the object associated with the key.
    public mainData getData(int id) {
        // We return null object, this method never could be used,
        // because the key of the table has a multi key.
        return null;
    }

    // Return the object associated with the key.
    public mainData getData(int userid, String date, int hourid, int idAccount) {

        schedulesData data = new schedulesData();
        Criteria criteria = new Criteria();
        criteria.addEqualTo("userid", new Integer(userid));
        
        criteria.addEqualTo("hourid", new Integer(hourid));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of the exact organization
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        Iterator e = allLines.iterator();
        // If exists the record -MUST EXISTS ALWAYS
        if (e.hasNext()) {
            data = (schedulesData) e.next();
        }

        // We return the object
        return data;
    }

    /**
     * Metodo que verifica si un registro existe o no
     */
    public boolean exists(int userid, String date, int hourid, int idAccount) {
        boolean existe = false;

        Criteria criteria = new Criteria();
        criteria.addEqualTo("userid", new Integer(userid));
        criteria.addEqualTo("day", date);
        criteria.addEqualTo("hourid", new Integer(hourid));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of the exact organization
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        Iterator e = allLines.iterator();
        // If exists the record -MUST EXISTS ALWAYS
        if (e.hasNext()) {
            existe = true;
        }


        return existe;
    }

    /*  public java.math.BigDecimal getTotalTaskActualTime(int taskid, int idAccount) throws PersistenceBrokerException {
    // Query of all the schedules
    Criteria criteria = new Criteria();
    criteria.addEqualTo("taskid", new Integer(taskid));
    criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
    ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);
    // define the 'columns' of the report
    q.setColumns(new String[]{"count(*)"});
    Iterator iter = broker.getReportQueryIteratorByQuery(q);
    Integer total = new Integer(0);
    if (iter.hasNext()) {
    Object[] arr = (Object[]) iter.next();
    if (arr[0].getClass().getName().equalsIgnoreCase("java.math.BigDecimal")) {
    total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
    } else {
    total = (Integer) arr[0];
    }
    // En caso de que sea nulo el resultado, se regresa 0
    if (total == null) {
    total = new Integer(1);
    }
    }
    // Se modifica la variable privada de total
    return new java.math.BigDecimal(total.doubleValue());
    }
     */
    public java.math.BigDecimal getTotalTaskRealHours(int taskid, int idAccount) throws PersistenceBrokerException {

        // Query of all the schedules
        Criteria criteria = new Criteria();
        criteria.addEqualTo("taskid", new Integer(taskid));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);

        // define the 'columns' of the report
        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
            q.setColumns(new String[]{"COALESCE(sum(realtime_Hours),0)"});
        } else {
            q.setColumns(new String[]{"nvl(sum(realtime_Hours),0)"});
        }
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        Integer total = new Integer(0);
        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            //total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
            total = new Integer((arr[0].toString()));
        }
        // Se modifica la variable privada de total
        return new java.math.BigDecimal(total.doubleValue());
    }
    
        public java.math.BigDecimal getTotalTaskRealHoursByDay(int idAccount, String day, String[] idMembers
                , String[] projects, String[] priorities, String[] status, String[] typeTasks, String query,
                String chargeable) throws PersistenceBrokerException {

        // Query of all the schedules
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        criteria.addEqualTo("day", day);
        criteria.addLike("parentTask.name", query);
        
        // Variable temporal
        ArrayList lista = new ArrayList();
                // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (idMembers[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(idMembers);
            criteria.addIn("parentTask.assigned_to", lista);
        }
        
                // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(projects);
            criteria.addIn("parentTask.project", lista);
        }

        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(priorities);
            criteria.addIn("parentTask.priority", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(status);
            criteria.addIn("parentTask.status", lista);
        }
        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(typeTasks);
            criteria.addIn("parentTask.type_task", lista);
        }

        if (chargeable.equalsIgnoreCase("ALL") == false) {
        criteria.addLike("parentTask.collect", chargeable);
        }
        
        ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);

        // define the 'columns' of the report
        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
            q.setColumns(new String[]{"COALESCE(sum(realtime_Hours),0)"});
        } else {
            q.setColumns(new String[]{"nvl(sum(realtime_Hours),0)"});
        }
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        Integer total = new Integer(0);
        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            //total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
            total = new Integer((arr[0].toString()));
        }
        // Se modifica la variable privada de total
        return new java.math.BigDecimal(total.doubleValue());
    }

    public java.math.BigDecimal getTotalTaskRealMinutes(int taskid, int idAccount) throws PersistenceBrokerException {

        // Query of all the schedules
        Criteria criteria = new Criteria();
        criteria.addEqualTo("taskid", new Integer(taskid));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);

        // define the 'columns' of the report
        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
            q.setColumns(new String[]{"COALESCE(sum(realtime_minutes),0)"});
        } else {
            q.setColumns(new String[]{"nvl(sum(realtime_minutes),0)"});
        }
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        Integer total = new Integer(0);
        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            //total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
            total = new Integer((arr[0]).toString());
        }
        // Se modifica la variable privada de total
        return new java.math.BigDecimal(total.doubleValue());
    }

       public java.math.BigDecimal getTotalTaskRealMinutesByDay(int idAccount, String day, String[] idMembers
                , String[] projects, String[] priorities, String[] status, String[] typeTasks, String query,
                String chargeable) throws PersistenceBrokerException {

        // Query of all the schedules
        Criteria criteria = new Criteria();
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        criteria.addEqualTo("day", day);
        criteria.addLike("parentTask.name", query);

                // Variable temporal
        ArrayList lista = new ArrayList();
                // Si en la lista no viene ningun ALL, se agrega el criterio de miembros
        if (idMembers[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(idMembers);
            criteria.addIn("parentTask.assigned_to", lista);
        }
        
                        // Si en la lista no viene ningun ALL, se agrega el criterio
        if (projects[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(projects);
            criteria.addIn("parentTask.project", lista);
        }

        if (priorities[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(priorities);
            criteria.addIn("parentTask.priority", lista);
        }

        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (status[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(status);
            criteria.addIn("parentTask.status", lista);
        }
        // Si en la lista no viene ningun ALL, se agrega el criterio de status
        if (typeTasks[0].equalsIgnoreCase("ALL") == false) {
            lista = this.convertToArray(typeTasks);
            criteria.addIn("parentTask.type_task", lista);
        }
        
        if (chargeable.equalsIgnoreCase("ALL") == false) {
        criteria.addLike("parentTask.collect", chargeable);
        }
                
        ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);

        // define the 'columns' of the report
        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
            q.setColumns(new String[]{"COALESCE(sum(realtime_minutes),0)"});
        } else {
            q.setColumns(new String[]{"nvl(sum(realtime_minutes),0)"});
        }
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        Integer total = new Integer(0);
        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            //total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
            total = new Integer((arr[0]).toString());
        }
        // Se modifica la variable privada de total
        return new java.math.BigDecimal(total.doubleValue());
    }

    public java.math.BigDecimal getTotalTaskRealHoursbyDate(int taskid, int userid, String date, int idAccount) throws PersistenceBrokerException {

        // Query of all the schedules
        Criteria criteria = new Criteria();
        criteria.addEqualTo("taskid", new Integer(taskid));
        criteria.addEqualTo("userid", new Integer(userid));
        criteria.addEqualTo("day", date);
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);

        // define the 'columns' of the report
        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
            q.setColumns(new String[]{"COALESCE(sum(realtime_Hours),0)"});
        } else {
            // define the 'columns' of the report
            q.setColumns(new String[]{"nvl(sum(realtime_Hours),0)"});
        }
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        Integer total = new Integer(0);
        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            //total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
            total = new Integer(arr[0].toString());
        }
        // Se modifica la variable privada de total
        return new java.math.BigDecimal(total.doubleValue());
    }

    public java.math.BigDecimal getTotalTaskRealMinutesbyDate(int taskid, int userid, String date, int idAccount) throws PersistenceBrokerException {

        // Query of all the schedules
        Criteria criteria = new Criteria();
        criteria.addEqualTo("taskid", new Integer(taskid));
        criteria.addEqualTo("userid", new Integer(userid));
        criteria.addEqualTo("day", date);
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);

        // define the 'columns' of the report
        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
            q.setColumns(new String[]{"COALESCE(sum(realtime_minutes),0)"});
        } else {
            q.setColumns(new String[]{"nvl(sum(realtime_minutes),0)"});
        }
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        Integer total = new Integer(0);
        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
           // total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
             total = new Integer(arr[0].toString());
        }
        // Se modifica la variable privada de total
        return new java.math.BigDecimal(total.doubleValue());
    }
    
    

    public java.math.BigDecimal getTotalTaskRealHoursbyDate(int taskid, String dateI, String dateF, int idAccount) throws PersistenceBrokerException {

        // Query of all the schedules
        Criteria criteria = new Criteria();
        criteria.addEqualTo("taskid", new Integer(taskid));

        criteria.addGreaterOrEqualThan("day", dateI);
        criteria.addLessOrEqualThan("day", dateF);
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);

        // define the 'columns' of the report
        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
            q.setColumns(new String[]{"COALESCE(sum(realtime_Hours),0)"});
        } else {
            q.setColumns(new String[]{"nvl(sum(realtime_Hours),0)"});
        }
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        BigDecimal total = new BigDecimal(0);
        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            //total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
            total = new BigDecimal(arr[0].toString());
        }
        // Se modifica la variable privada de total
        return new java.math.BigDecimal(total.doubleValue());
    }
    
//    public java.math.BigDecimal getTotalTaskRealHoursbyDay(String day, int idAccount) throws PersistenceBrokerException {
//
//        // Query of all the schedules
//        Criteria criteria = new Criteria();
//
//        criteria.addLessOrEqualThan("day", day);
//        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
//        ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);
//
//        // define the 'columns' of the report
//        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
//            q.setColumns(new String[]{"COALESCE(sum(realtime_Hours),0)"});
//        } else {
//            q.setColumns(new String[]{"nvl(sum(realtime_Hours),0)"});
//        }
//        Iterator iter = broker.getReportQueryIteratorByQuery(q);
//        BigDecimal total = new BigDecimal(0);
//        if (iter.hasNext()) {
//            Object[] arr = (Object[]) iter.next();
//            //total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
//            total = new BigDecimal(arr[0].toString());
//        }
//        // Se modifica la variable privada de total
//        return new java.math.BigDecimal(total.doubleValue());
//    }

    public java.math.BigDecimal getTotalTaskRealMinutesbyDate(int taskid, String dateI, String dateF, int idAccount) throws PersistenceBrokerException {

        // Query of all the schedules
        Criteria criteria = new Criteria();
        criteria.addEqualTo("taskid", new Integer(taskid));

        criteria.addGreaterOrEqualThan("day", dateI);
        criteria.addLessOrEqualThan("day", dateF);
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));

        ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);

        // define the 'columns' of the report
        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
            q.setColumns(new String[]{"COALESCE(sum(realtime_minutes),0)"});
        } else {
            q.setColumns(new String[]{"nvl(sum(realtime_minutes),0)"});
        }
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        BigDecimal total = new BigDecimal(0);
        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            //total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
             total = new BigDecimal(arr[0].toString());
        }
        // Se modifica la variable privada de total
        return new java.math.BigDecimal(total.doubleValue());
    }
    
//    public java.math.BigDecimal getTotalTaskRealMinutesbyDay(String day, int idAccount) throws PersistenceBrokerException {
//
//        // Query of all the schedules
//        Criteria criteria = new Criteria();
//
//        criteria.addGreaterOrEqualThan("day", day);
//        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
//
//        ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);
//
//        // define the 'columns' of the report
//        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
//            q.setColumns(new String[]{"COALESCE(sum(realtime_minutes),0)"});
//        } else {
//            q.setColumns(new String[]{"nvl(sum(realtime_minutes),0)"});
//        }
//        Iterator iter = broker.getReportQueryIteratorByQuery(q);
//        BigDecimal total = new BigDecimal(0);
//        if (iter.hasNext()) {
//            Object[] arr = (Object[]) iter.next();
//            //total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
//             total = new BigDecimal(arr[0].toString());
//        }
//        // Se modifica la variable privada de total
//        return new java.math.BigDecimal(total.doubleValue());
//    }

    /* Devuelve la cantidad de horas de esta tarea con base en el usuario dado */
    /*  public java.math.BigDecimal getTotalTaskActualTime(int taskid, int idMember,
    Timestamp start, Timestamp end, int idAccount) throws PersistenceBrokerException {
    // Query of all the schedules
    Criteria criteria = new Criteria();
    criteria.addEqualTo("taskid", new Integer(taskid));
    criteria.addEqualTo("userid", new Integer(idMember));
    criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
    // Se toma el date stamp y se convierte en un string de la forma
    //yyyy-mm-dd
    Calendar calendar = Calendar.getInstance();
    calendar.setTimeInMillis(start.getTime());
    String date, month, day;
    // Se saca el mes y el dia con dos digitos
    month = "" + (calendar.get(calendar.MONTH) + 1);
    if (month.length() < 2) {
    month = "0" + month;
    }
    day = "" + calendar.get(calendar.DAY_OF_MONTH);
    if (day.length() < 2) {
    day = "0" + day;
    }
    date = calendar.get(calendar.YEAR) + "-" +
    month + "-" + day;
    criteria.addGreaterOrEqualThan("day", date);
    // la fecha de inicio debe ser menor o igual q la dada
    calendar.setTimeInMillis(end.getTime());
    // Se saca el mes y el dia con dos digitos
    month = "" + (calendar.get(calendar.MONTH) + 1);
    if (month.length() < 2) {
    month = "0" + month;
    }
    day = "" + calendar.get(calendar.DAY_OF_MONTH);
    if (day.length() < 2) {
    day = "0" + day;
    }
    date = calendar.get(calendar.YEAR) + "-" +
    month + "-" + day;
    criteria.addLessOrEqualThan("day", date);
    ReportQueryByCriteria q = QueryFactory.newReportQuery(schedulesData.class, criteria);
    // define the 'columns' of the report
    q.setColumns(new String[]{"count(*)"});
    Iterator iter = broker.getReportQueryIteratorByQuery(q);
    Integer total = new Integer(0);
    if (iter.hasNext()) {
    Object[] arr = (Object[]) iter.next();
    if (arr[0].getClass().getName().equalsIgnoreCase("java.math.BigDecimal")) {
    total = new Integer(((java.math.BigDecimal) arr[0]).intValue());
    } else {
    System.out.println("Integer");
    total = (Integer) arr[0];
    }
    // En caso de que sea nulo el resultado, se regresa 0
    if (total == null) {
    total = new Integer(0);
    }
    }
    // Se modifica la variable privada de total
    return new java.math.BigDecimal(total.doubleValue());
    }
     */
    public java.util.Iterator getList(int userid, String date, int idAccount) throws PersistenceBrokerException {
        // Query of all the schedules
        Criteria criteria = new Criteria();
        criteria.addEqualTo("userid", new Integer(userid));
        criteria.addEqualTo("day", date);
        // define the 'columns' of the report
        if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
            criteria.addOrderByAscending("to_timestamp(day || hour_start, 'YYYY-MM-DDHH:MI am')");
        } else {
            criteria.addOrderByAscending("to_date(day || hour_start, 'RRRR-MM-DDHH:MI am')");
        }
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result to print each Service
        return allLines.iterator();
    }

    /*
     * Regresa un listado del contenido de ese dia, con base en project id dado
     */
    public java.util.Iterator getList(int userid, String date, int projectId, int idAccount)
            throws PersistenceBrokerException {
        // Query of all the schedules
        Criteria criteria = new Criteria();
        criteria.addEqualTo("userid", new Integer(userid));
        criteria.addEqualTo("day", date);
        criteria.addEqualTo("parentTask.project", new Integer(projectId));
         if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
            criteria.addOrderByAscending("to_timestamp(day || hour_start, 'YYYY-MM-DDHH:MI am')");
        } else {
        criteria.addOrderByAscending("to_date(day || hour_start, 'RRRR-MM-DDHH:MI am')");
        }
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        // now iterate over the result to print each Service
        return allLines.iterator();
    }

    public java.util.Iterator getListByDate(String sortColumnName,
            String sortOrder, int page, int userid, int idAccount) throws PersistenceBrokerException {
        String sql = "SELECT DISTINCT day FROM schedules where userid = " + userid + " and id_account=" + idAccount + " order by day DESC ";

        QueryBySQL query = new QueryBySQL(schedulesData.class, sql);

        
        ArrayList listof = new ArrayList();
        // ask the broker to retrieve the Extent collection
        Iterator iter = broker.getReportQueryIteratorByQuery(query);
        while (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            for (int i = 0; i < arr.length; i++) {
                listof.add(arr[i]);
            }
        }
        if (page > 0) {
            // Se determinan los limites superior e inferior
            int inicio = (page - 1) * GAP_SIZE * 3;
            int fin = page * GAP_SIZE * 3;

            setCount(new Integer(listof.size()));

            // now iterate over the result
            return getCollection(listof, inicio, fin);
        } else {
            return listof.iterator();
        }

    }

    /**
     * Metodo que regresa la lista de actividades que estan registradas en un horario
     * para una fecha y usuario determinado.
     */
    public java.util.ArrayList getListByDate(String sortColumnName,
            String sortOrder, int userid, Calendar date, int idAccount) throws PersistenceBrokerException {

        String year = "" + date.get(Calendar.YEAR);
        String month = "" + (date.get(Calendar.MONTH) + 1);
        String day = "" + date.get(Calendar.DAY_OF_MONTH);

        if (month.length() == 1) {
            month = "0" + month;
        }
        if (day.length() == 1) {
            day = "0" + day;
        }


        String fecha = year + "-" + month + "-" + day;


        Criteria criteria = new Criteria();
        criteria.addEqualTo("userid", new Integer(userid));
        criteria.addEqualTo("day", fecha);
         if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
            criteria.addOrderByAscending("to_timestamp(day || hour_start, 'YYYY-MM-DDHH:MI am')");
        } else {
            criteria.addOrderByAscending("to_date(day || hour_start, 'RRRR-MM-DDHH:MI am')");
        }
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);


        return new ArrayList(allLines);

    }

    /**
     * Metodo que determina si hay un conflicto entre las horas que se estan colocando
     *para una fecha de horario determinada.
     */
    public boolean isConflict(int userid, String hourIni, String hourEnd, String day, int accountid) {
        boolean conflicto = false;
        try {
            System.out.println("IS CONFLICT");
            System.out.println(userid);
            System.out.println(hourIni);
            System.out.println(hourEnd);
            System.out.println(day);
            System.out.println(accountid);
            /*String sql = "SELECT s.hourid" +
            " FROM schedules s" +
            " WHERE s.userid = " + userid +
            " AND s.DAY = '" + day + "'" +
            " AND s.id_account = " + accountid +
            " AND ( TO_DATE( '" + day + hourIni + "', 'RRRR-MM-DDHH:MI am' ) BETWEEN TO_DATE( s.DAY || s.hour_start " +
            " ,'RRRR-MM-DDHH:MI am') AND(   TO_DATE( s.DAY || s.hour_end " +
            " ,'RRRR-MM-DDHH:MI am')- ( 1 /( 24 * 60 * 60 ) ))" +
            " OR ( TO_DATE( '" + day + hourEnd + "', 'RRRR-MM-DDHH:MI am' ) -( 1 /( 24 * 60 * 60 ) ) ) " +
            " BETWEEN TO_DATE( s.DAY || s.hour_start, 'RRRR-MM-DDHH:MI am' ) " +
            " AND( TO_DATE( s.DAY || s.hour_end, 'RRRR-MM-DDHH:MI am' ) -( 1 /( 24 * 60 * 60 ) ) ) " +
            " OR TO_DATE( s.DAY || s.hour_start, 'RRRR-MM-DDHH:MI am' ) BETWEEN TO_DATE( '" + day + hourIni + "'" +
            " ,'RRRR-MM-DDHH:MI am') AND(   TO_DATE( '" + day + hourEnd + "','RRRR-MM-DDHH:MI am') - ( 1 /( 24 * 60 * 60 ))" +
            " ))";
            QueryBySQL query = new QueryBySQL(schedulesData.class, sql);
            ArrayList listof = new ArrayList();
            // ask the broker to retrieve the Extent collection
            Iterator iter = broker.getReportQueryIteratorByQuery(query);*/

            java.sql.Connection con = broker.serviceConnectionManager().getConnection();
            java.sql.CallableStatement proc = null;
            boolean band = true;

            if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
                proc = con.prepareCall("{call isconflict(?,?,?,?,?)}");
            } else {
                band = false;
                proc = con.prepareCall("{call isconflict(?,?,?,?,?,?)}");
                proc.registerOutParameter(6, java.sql.Types.NUMERIC);
            }
            proc.setInt(1, userid);
            proc.setString(2, day);
            proc.setInt(3, accountid);
            proc.setString(4, hourIni);
            proc.setString(5, hourEnd);
            if (band) {
                // Ejecutar myudr
                ResultSet rs = proc.executeQuery();
                System.out.println(proc);
                if (rs.next()) {
                    if (rs.getInt(1) != 0) {
                        conflicto = true;
                    }
                }

            } else {
                proc.executeUpdate();
                if (proc.getInt(6) != 0) {
                    conflicto = true;
                }
            }
            proc.close();
        } catch (Exception lola) {
            System.out.println(lola);
        }

        return conflicto;
    }

    /*
     * Metodo que retorna una lista de todas las fechas para ese usuario, en donde
     * al menos tiene un entrada de una tarea del proyecto dado.
     */
    public java.util.Iterator getListByProject(String sortColumnName,
            String sortOrder, int userid, int projectid, int idAccount) throws PersistenceBrokerException {
        String sql = "SELECT DISTINCT day FROM schedules, tasks where schedules.userid = " + userid +
                " and schedules.taskid = tasks.id and " +
                " tasks.project = " + projectid +
                " and schedules.id_account = " + idAccount +
                " and schedules.id_account = tasks.id_account " +
                " order by day ASC ";
        QueryBySQL query = new QueryBySQL(schedulesData.class, sql);

        ArrayList listof = new ArrayList();
        // ask the broker to retrieve the Extent collection
        Iterator iter = broker.getReportQueryIteratorByQuery(query);
        while (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            for (int i = 0; i < arr.length; i++) {
                listof.add(arr[i]);
            }
        }
        return listof.iterator();
    }

    private void setTotalRows(Criteria criteria) {
        // Se almacena el maximo de registros verdaderos, para ello
        // se procede con un count
        ReportQueryByCriteria q = QueryFactory.newReportQuery(
                schedulesData.class, criteria);

        // define the 'columns' of the report
        q.setColumns(new String[]{"count(*)"});
        Iterator iter = broker.getReportQueryIteratorByQuery(q);
        Integer total = new Integer(0);

        if (iter.hasNext()) {
            Object[] arr = (Object[]) iter.next();
            total = (Integer) arr[0];

            // En caso de que sea nulo el resultado, se regresa 0
            if (total == null) {
                total = new Integer(0);
            }
        }

        // Se modifica la variable privada de total
        setCount(total);
    }

    /*
     * Metodo que elimina todas las referencias de un member en todos los schedules.
     */
    public void deleteAllReferences(int memberId, int idAccount) throws PersistenceBrokerException {
        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("userid", Integer.valueOf("" + memberId));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the teams
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // Se borra cada entrada
        while (e.hasNext()) {
            this.delete(e.next());
        }
    }

    /*
     * Metodo que elimina todas las referencias de un member en todos los schedules.
     */
    public void deleteAllReferencesbyAccount(int accountId) throws PersistenceBrokerException {
        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("id_account", Integer.valueOf("" + accountId));

        // Query of all the teams
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // Se borra cada entrada
        while (e.hasNext()) {
            this.delete(e.next());
        }
    }

    /**
     * Metodo que elimina todos los horarios de un usuario en una fecha
     * determinada.
     */
    public void deleteSchedule(int userid, String date, int idAccount) throws PersistenceBrokerException {

        Criteria criteria = new Criteria();
        criteria.addEqualTo("userid", new Integer(userid));
        criteria.addEqualTo("day", date);
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of the exact organization
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);
        Iterator e = allLines.iterator();
        // If exists the record -MUST EXISTS ALWAYS
        while (e.hasNext()) {
            this.delete(e.next());
        }
    }

    /*
     * Metodo que elimina todas las referencias de una tarea en todos los schedules.
     */
    public void deleteAllReferencesByTask(int taskid, int idAccount) throws PersistenceBrokerException {
        // New criteria for search
        Criteria criteria = new Criteria();

        // Se agrega el criteria por proyecto.
        criteria.addEqualTo("taskid", Integer.valueOf("" + taskid));
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        // Query of all the teams
        Query query = new QueryByCriteria(schedulesData.class, criteria);

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        Iterator e = allLines.iterator();

        // Se borra cada entrada
        while (e.hasNext()) {
            this.delete(e.next());
        }
    }

    /**
     * Regresa una lista del detalle de los horarios de un dia y usuario
     * determinado.
     */
    public ArrayList getItems(String[] horas, int userId, Calendar calendar, int idAccount) {
        // Debemos convertir el iterador en un arraylist.
        String date, month, day;

        // Se saca el mes y el dia con dos digitos
        month = "" + (calendar.get(calendar.MONTH) + 1);
        if (month.length() < 2) {
            month = "0" + month;
        }

        day = "" + calendar.get(calendar.DAY_OF_MONTH);
        if (day.length() < 2) {
            day = "0" + day;
        }

        date = calendar.get(calendar.YEAR) + "-" +
                month + "-" + day;


        Criteria criteria = new Criteria();
        criteria.addEqualTo("userid", new Integer(userId));
        criteria.addEqualTo("day", date);
        criteria.addEqualTo("id_account", Integer.valueOf("" + idAccount));
        ArrayList horasA = new ArrayList();

        for (int i = 0; i < horas.length; i++) {
            horasA.add(new Integer(horas[i]));
        }

        criteria.addIn("hourid", horasA);

        QueryByCriteria query = new QueryByCriteria(schedulesData.class, criteria);

        query.addOrderByAscending("hourid");

        // ask the broker to retrieve the Extent collection
        Collection allLines = broker.getCollectionByQuery(query);

        return new ArrayList(allLines);

    }

    /* Metodo que nos dice la diferencia entre 2 horas
     */
    public String getRegisteredHour(String start, String end) throws PersistenceBrokerException {

        System.out.println("EMPIEZA: "+start+ " TERMINA: "+ end);
        String result = null;
        String s = null;
        String e = null;

        if (start.split("am").length > 0) {
            s = "am";
        } else {
            s = "pm";
        }
        if (end.compareTo("12:00 am") == 0) {
            e = "pm";
            end = "11:59 pm";
        } else {
            if (end.split("pm").length > 0) {
                e = "pm";
            } else {
                e = "am";
            }
        }
        System.out.println("RESULTADO NUEVO: "+start+" , " + end+" , "+s+" , "+e );
        try {
            java.sql.CallableStatement proc = null;
            java.sql.Connection con = broker.serviceConnectionManager().getConnection();
            if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
                proc = con.prepareCall("{call GETREALTIMEHOUR(?,?,?,?)}");
                proc.setString(1, start);
                proc.setString(2, end);
                proc.setString(3, s);
                proc.setString(4, e);
                ResultSet rs = proc.executeQuery();
                if (rs.next()) {
                    result = String.valueOf(rs.getInt(1));
                }
            } else {
                proc = con.prepareCall("{call GETREALTIMEHOUR(?,?,?,?,?)}");
                proc.setString(1, start);
                proc.setString(2, end);
                proc.setString(3, s);
                proc.setString(4, e);
                proc.registerOutParameter(5, java.sql.Types.NUMERIC);
                proc.executeUpdate();
                result = String.valueOf(proc.getInt(5));
            }
            proc.close();
            con.close();
        } catch (Exception lola) {
            System.out.println(lola);
        }
        return result;
    }

    /* Metodo que nos dice la diferencia entre 2 horas
     */
    public String getRegisteredMinutes(
            String start, String end) throws PersistenceBrokerException {

        String result = null;
        String s = null;
        String e = null;

        if (start.split("am").length > 0) {
            s = "am";
        } else {
            s = "pm";
        }

        if (end.split("pm").length > 0) {
            e = "pm";
        } else {
            e = "am";
        }

        try {

            java.sql.Connection con = broker.serviceConnectionManager().getConnection();
            java.sql.CallableStatement proc = null;
            if (broker.serviceConnectionManager().getConnectionDescriptor().getJcdAlias().equals("postgreSQL")) {
                proc = con.prepareCall("{call GETREALTIMEMINUTES(?,?,?,?)}");
                proc.setString(1, start);
                proc.setString(2, end);
                proc.setString(3, s);
                proc.setString(4, e);
                ResultSet rs = proc.executeQuery();
                System.out.println(proc);
                if (rs.next()) {
                    result = String.valueOf(rs.getInt(1));
                }
            } else {
                proc = con.prepareCall("{call GETREALTIMEMINUTES(?,?,?,?,?)}");

                proc.setString(1, start);
                proc.setString(2, end);
                proc.setString(3, s);
                proc.setString(4, e);
                proc.registerOutParameter(5, java.sql.Types.NUMERIC);
                proc.executeUpdate();

                result =
                        String.valueOf(proc.getInt(5));
            }
            proc.close();
        } catch (Exception lola) {
            System.out.println(lola);
        }

        return result;
    }
    
        /* M�todo que convierte un String[] a un ArrayList */
    private ArrayList convertToArray(String[] lista) {

        ArrayList salida = new ArrayList();

        for (int i = 0; i < lista.length; i++) {

            salida.add(new Integer(Integer.parseInt(lista[i])));

        }



        return salida;

    }

}
